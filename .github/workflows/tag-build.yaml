---
name: Build release
on:
  workflow_dispatch: 
    inputs:
      artifact-tag:
        description: "The tag associated with the artifact to deploy (eg. v1.2.3)."
        type: string
        required: true
      # This is a workaround so that the actor who initiated a workflow run via a workflow dispatch event can determine the run ID of the started workflow run
      workflow-tag:
        description: "This field adds the provided value to a run step, allowing the calling actor to associate the started run with the GHA run ID."
        type: string
        required: false
  pull_request:
    branches:
      - master
  push:
    tags:
      - "v*"
    branches:
      - master

concurrency:
  group: "Limit to one build at a time for ref ${{ format('refs/tags/{0}', inputs.artifact-tag) || github.ref }}"
  cancel-in-progress: true

env:
  TESTVAR: testval

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-variables.outputs.environment }}
      version: ${{ steps.set-variables.outputs.version }}
      gitref: ${{ steps.set-variables.outputs.gitref }}
    steps:
      # TODO this really needs to move to shared workflows. This is the ~fourth place
      # that this logic has been used.
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set environment output values
        id: set-variables
        env:
          GITHUB_EVENT_REF: ${{ github.ref || github.action_ref }}
          GITHUB_EVENT_NAME: ${{ github.event_name}}
          INPUT_VERSION: ${{ inputs.artifact-tag }}
          SEMVER_REGEX: ^v?(?:0|[1-9]\d*)\.(?:0|[1-9]\d*)\.(?:0|[1-9]\d*)(?:-(?:(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?:[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$
        run: |
          generate_version() {
              GITREF=$1
              VERSION_BASE=$(git describe --tags --match "v[[:digit:]]*.[[:digit:]]*.[[:digit:]]")
              VERSION_METADATA=$(git show-ref --heads --tags --hash=8 "$GITREF" | head -n 1)
              echo "$VERSION_BASE+$VERSION_METADATA"
          }
          
          get_output_vars() {
              case "$GITHUB_EVENT_NAME" in
                  "workflow_dispatch")
                      # Case: workflow dispatch event. Pull most vars from inputs.
                      echo "environment=build-stage"
                      echo "version=$INPUT_VERSION"
                      echo "gitref=$GITHUB_EVENT_REF"
                      ;;
                  "pull_request")
                      echo "environment=build-stage"
                      echo "version=$(generate_version "$GITHUB_EVENT_REF")"
                      echo "gitref=$GITHUB_EVENT_REF"
                      ;;
                  "push")
                      REF_TYPE=$(echo "$GITHUB_EVENT_REF" | cut -d'/' -f2)
                      # Case: commit push event.
                      if [ "$REF_TYPE" != "tags" ]; then
                          echo "environment=build-stage"
                          echo "version=$(generate_version "$GITHUB_EVENT_REF")"
                          echo "gitref=$GITHUB_EVENT_REF"
                          return
                      fi
          
                      VERSION_TAG=$(echo "$GITHUB_EVENT_REF" | cut -d'/' -f3)
          
                      # Case: tag event with prerelease version.
                      if [ "${VERSION_TAG#*-}" != "$VERSION_TAG" ]; then
                          echo "environment=build-stage"
                          echo "version=$VERSION_TAG"
                          echo "gitref=$GITHUB_EVENT_REF"
                          return
                      fi
          
                      # Case: tag event with release version. Only this
                      # should go to prod.
                      echo "environment=build-prod"
                      echo "version=$VERSION_TAG"
                      echo "gitref=$GITHUB_EVENT_REF"
                      ;;
                  *)
                      >&2 echo "Unknown GHA event $GITHUB_EVENT_NAME, failing" 
                      exit 1
                      ;;
              esac
          }
          
          get_output_vars >> "$GITHUB_OUTPUT"
          
          # Validate the semver
          . "$GITHUB_OUTPUT"  # Load the variables into the current environment
          (echo "$version" | grep -qP "$SEMVER_REGEX") || (echo "The artifact version $version is not a valid semver-coerced value"; exit 1)
        
          # Log the build details
          echo "Built config:" | tee -a "$GITHUB_STEP_SUMMARY"
          cat "$GITHUB_OUTPUT" | while read line; do
            echo "* $line" | tee -a "$GITHUB_STEP_SUMMARY"
          done
      - name: ${{ inputs.workflow-tag }}
        if: inputs.workflow-tag != ''
        run: |
          # Do nothing
  # Each section here could be split out into a separate job, at the cost of slightly increased complexity.
  # This would improve the (already somewhat fast) performance a bit, but I'm not sure if it's worth the
  # tradeoff.
  build-plugins:
    needs:
      - setup
    runs-on: ubuntu-22.04-32core
    environment: ${{ needs.setup.outputs.environment }}
    permissions:
      contents: read
      id-token: write
    env:
      ARTIFACT_DIRECTORY: /tmp/build
    steps:
      # Setup
      - name: Enable performance telemetry/metrics
        uses: catchpoint/workflow-telemetry-action@v1
        with:
          comment_on_pr: false
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.setup.outputs.gitref }}
          fetch-depth: 0  # This is required by some of the commands in the makefiles
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: "./go.mod"
          cache-dependency-path: "./go.sum"
          check-latest: true
      - name: Set environment variables for Makefiles
        env:
          VERSION_TAG: ${{ needs.setup.outputs.version }}
        run: |
          {
            echo "VERSION=${VERSION_TAG##v}"
            echo "GITREF=$VERSION_TAG" >> "$GITHUB_ENV"
            echo "GNUMAKEFLAGS=-j$(nproc)"
          } >> "$GITHUB_ENV"
      # File artifacts
      - name: Build the release tarballs
        run: |
          # Binaries and Helm charts
          make releases helm-package-charts

          # Terraform provider and event handler, as appropriate
          go install github.com/konoui/lipo@latest  # At some point this should be merged into the buildbox
          make OS=linux ARCH=amd64 release/terraform release/event-handler
          make OS=linux ARCH=arm64 release/terraform
          make OS=darwin ARCH=amd64 release/terraform release/event-handler
          make OS=darwin ARCH=arm64 release/terraform
          make OS=darwin ARCH=universal release/terraform
      - name: Collect the build files
        run: |
          mkdir -pv "$ARTIFACT_DIRECTORY"
          cp $(find . '(' -name "*.tar.gz" -o -name "*.tgz" ')' -type f) "$ARTIFACT_DIRECTORY/"
      - name: Generate checksum files for built files
        working-directory: ${{ env.ARTIFACT_DIRECTORY }}
        run: |
          find . '(' -name "*.tar.gz" -o -name "*.tgz" ')' -type f -exec sh -c 'sha256sum "$(basename {})" > "{}.sha256"' \;
          echo "Artifacts:"
          ls -lh
      - name: Assume AWS role for uploading the artifacts
        uses: aws-actions/configure-aws-credentials@010d0da01d0b5a38af31e9c3470dbfdabdecca3a # v4.0.1
        with:
          role-skip-session-tagging: true
          aws-region: us-west-2
          role-to-assume: ${{ vars.ARTIFACT_UPLOAD_AWS_ROLE }}
          role-session-name: "artifact-upload-${{ github.run_number }}"
          role-duration-seconds: 900
      - name: Upload artifacts to S3
        working-directory: ${{ env.ARTIFACT_DIRECTORY }}
        env:
          ARTIFACT_BUCKET: ${{ vars.ARTIFACT_SOURCE_BUCKET }}
          ARTIFACT_VERSION: ${{ needs.setup.outputs.version }}
        run: aws s3 cp . "s3://$ARTIFACT_BUCKET/teleport-plugins/tag/$ARTIFACT_VERSION/" --recursive
      # Container artifacts
      - name: Assume AWS role for pushing the container images
        uses: aws-actions/configure-aws-credentials@010d0da01d0b5a38af31e9c3470dbfdabdecca3a # v4.0.1
        with:
          role-skip-session-tagging: true
          aws-region: us-west-2
          role-to-assume: ${{ vars.CONTAINER_IMAGE_UPLOAD_AWS_ROLE }}
          role-session-name: "container-image-upload-${{ github.run_number }}"
          role-duration-seconds: 900
      - name: Authenticate with ECR
        env:
          CONTAINER_IMAGE_PRIVATE_REGISTRY: ${{ vars.CONTAINER_IMAGE_PRIVATE_REGISTRY }}
        run: |
          aws ecr get-login-password | docker login -u="AWS" --password-stdin "$CONTAINER_IMAGE_PRIVATE_REGISTRY"
      - name: Build and push the container images
        env:
          CONTAINER_IMAGE_PRIVATE_REGISTRY: ${{ vars.CONTAINER_IMAGE_PRIVATE_REGISTRY }}
        run: |
          # Access plugins and event handler
          make DOCKER_PRIVATE_REGISTRY="$CONTAINER_IMAGE_PRIVATE_REGISTRY" \
            docker-push-access-all docker-push-event-handler
