/*
Copyright 2015-2021 Gravitational, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types.proto

package tfschema

import (
	fmt "fmt"
	math "math"
	time "time"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	accessors "github.com/gravitational/protoc-gen-terraform/accessors"
	types "github.com/gravitational/teleport/api/types"
	schema "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	validation "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	_ "google.golang.org/protobuf/types/known/timestamppb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

var (
	// SchemaDatabaseV3 is schema for DatabaseV3 represents a single proxied database.
	SchemaDatabaseV3 = GenSchemaDatabaseV3()
	// SchemaMetaDatabaseV3 is schema metadata for DatabaseV3 represents a single proxied database.
	SchemaMetaDatabaseV3 = GenSchemaMetaDatabaseV3()
	// SchemaAppV3 is schema for AppV3 represents an app resource.
	SchemaAppV3 = GenSchemaAppV3()
	// SchemaMetaAppV3 is schema metadata for AppV3 represents an app resource.
	SchemaMetaAppV3 = GenSchemaMetaAppV3()
	// SchemaProvisionTokenV2 is schema for ProvisionTokenV2 specifies provisioning token
	SchemaProvisionTokenV2 = GenSchemaProvisionTokenV2()
	// SchemaMetaProvisionTokenV2 is schema metadata for ProvisionTokenV2 specifies provisioning token
	SchemaMetaProvisionTokenV2 = GenSchemaMetaProvisionTokenV2()
	// SchemaClusterAuditConfigV2 is schema for ClusterAuditConfigV2 represents audit log settings in the cluster.
	SchemaClusterAuditConfigV2 = GenSchemaClusterAuditConfigV2()
	// SchemaMetaClusterAuditConfigV2 is schema metadata for ClusterAuditConfigV2 represents audit log settings in the cluster.
	SchemaMetaClusterAuditConfigV2 = GenSchemaMetaClusterAuditConfigV2()
	// SchemaClusterNetworkingConfigV2 is schema for ClusterNetworkingConfigV2 contains cluster-wide networking configuration.
	SchemaClusterNetworkingConfigV2 = GenSchemaClusterNetworkingConfigV2()
	// SchemaMetaClusterNetworkingConfigV2 is schema metadata for ClusterNetworkingConfigV2 contains cluster-wide networking configuration.
	SchemaMetaClusterNetworkingConfigV2 = GenSchemaMetaClusterNetworkingConfigV2()
	// SchemaSessionRecordingConfigV2 is schema for SessionRecordingConfigV2 contains session recording configuration.
	SchemaSessionRecordingConfigV2 = GenSchemaSessionRecordingConfigV2()
	// SchemaMetaSessionRecordingConfigV2 is schema metadata for SessionRecordingConfigV2 contains session recording configuration.
	SchemaMetaSessionRecordingConfigV2 = GenSchemaMetaSessionRecordingConfigV2()
	// SchemaAuthPreferenceV2 is schema for AuthPreferenceV2 implements the AuthPreference interface.
	SchemaAuthPreferenceV2 = GenSchemaAuthPreferenceV2()
	// SchemaMetaAuthPreferenceV2 is schema metadata for AuthPreferenceV2 implements the AuthPreference interface.
	SchemaMetaAuthPreferenceV2 = GenSchemaMetaAuthPreferenceV2()
	// SchemaRoleV4 is schema for RoleV4 represents role resource specification
	SchemaRoleV4 = GenSchemaRoleV4()
	// SchemaMetaRoleV4 is schema metadata for RoleV4 represents role resource specification
	SchemaMetaRoleV4 = GenSchemaMetaRoleV4()
	// SchemaUserV2 is schema for UserV2 is version 2 resource spec of the user
	SchemaUserV2 = GenSchemaUserV2()
	// SchemaMetaUserV2 is schema metadata for UserV2 is version 2 resource spec of the user
	SchemaMetaUserV2 = GenSchemaMetaUserV2()
	// SchemaOIDCConnectorV2 is schema for OIDCConnectorV2 represents an OIDC connector.
	SchemaOIDCConnectorV2 = GenSchemaOIDCConnectorV2()
	// SchemaMetaOIDCConnectorV2 is schema metadata for OIDCConnectorV2 represents an OIDC connector.
	SchemaMetaOIDCConnectorV2 = GenSchemaMetaOIDCConnectorV2()
	// SchemaSAMLConnectorV2 is schema for SAMLConnectorV2 represents a SAML connector.
	SchemaSAMLConnectorV2 = GenSchemaSAMLConnectorV2()
	// SchemaMetaSAMLConnectorV2 is schema metadata for SAMLConnectorV2 represents a SAML connector.
	SchemaMetaSAMLConnectorV2 = GenSchemaMetaSAMLConnectorV2()
	// SchemaGithubConnectorV3 is schema for GithubConnectorV3 represents a Github connector.
	SchemaGithubConnectorV3 = GenSchemaGithubConnectorV3()
	// SchemaMetaGithubConnectorV3 is schema metadata for GithubConnectorV3 represents a Github connector.
	SchemaMetaGithubConnectorV3 = GenSchemaMetaGithubConnectorV3()
	// SchemaTrustedClusterV2 is schema for TrustedClusterV2 represents a Trusted Cluster.
	SchemaTrustedClusterV2 = GenSchemaTrustedClusterV2()
	// SchemaMetaTrustedClusterV2 is schema metadata for TrustedClusterV2 represents a Trusted Cluster.
	SchemaMetaTrustedClusterV2 = GenSchemaMetaTrustedClusterV2()
)

// SuppressDurationChange supresses change for equal durations written differently, ex.: "1h" and "1h0m"
func SuppressDurationChange(k string, old string, new string, d *schema.ResourceData) bool {
	o, err := time.ParseDuration(old)
	if err != nil {
		return false
	}

	n, err := time.ParseDuration(new)
	if err != nil {
		return false
	}

	return o == n
}
func FromTerraformDatabaseV3(data *schema.ResourceData, obj *types.DatabaseV3) error {
	return accessors.FromTerraform(obj, data, SchemaDatabaseV3, SchemaMetaDatabaseV3)
}

func ToTerraformDatabaseV3(obj *types.DatabaseV3, data *schema.ResourceData) error {
	return accessors.ToTerraform(obj, data, SchemaDatabaseV3, SchemaMetaDatabaseV3)
}
func FromTerraformAppV3(data *schema.ResourceData, obj *types.AppV3) error {
	return accessors.FromTerraform(obj, data, SchemaAppV3, SchemaMetaAppV3)
}

func ToTerraformAppV3(obj *types.AppV3, data *schema.ResourceData) error {
	return accessors.ToTerraform(obj, data, SchemaAppV3, SchemaMetaAppV3)
}
func FromTerraformProvisionTokenV2(data *schema.ResourceData, obj *types.ProvisionTokenV2) error {
	return accessors.FromTerraform(obj, data, SchemaProvisionTokenV2, SchemaMetaProvisionTokenV2)
}

func ToTerraformProvisionTokenV2(obj *types.ProvisionTokenV2, data *schema.ResourceData) error {
	return accessors.ToTerraform(obj, data, SchemaProvisionTokenV2, SchemaMetaProvisionTokenV2)
}
func FromTerraformClusterAuditConfigV2(data *schema.ResourceData, obj *types.ClusterAuditConfigV2) error {
	return accessors.FromTerraform(obj, data, SchemaClusterAuditConfigV2, SchemaMetaClusterAuditConfigV2)
}

func ToTerraformClusterAuditConfigV2(obj *types.ClusterAuditConfigV2, data *schema.ResourceData) error {
	return accessors.ToTerraform(obj, data, SchemaClusterAuditConfigV2, SchemaMetaClusterAuditConfigV2)
}
func FromTerraformClusterNetworkingConfigV2(data *schema.ResourceData, obj *types.ClusterNetworkingConfigV2) error {
	return accessors.FromTerraform(obj, data, SchemaClusterNetworkingConfigV2, SchemaMetaClusterNetworkingConfigV2)
}

func ToTerraformClusterNetworkingConfigV2(obj *types.ClusterNetworkingConfigV2, data *schema.ResourceData) error {
	return accessors.ToTerraform(obj, data, SchemaClusterNetworkingConfigV2, SchemaMetaClusterNetworkingConfigV2)
}
func FromTerraformSessionRecordingConfigV2(data *schema.ResourceData, obj *types.SessionRecordingConfigV2) error {
	return accessors.FromTerraform(obj, data, SchemaSessionRecordingConfigV2, SchemaMetaSessionRecordingConfigV2)
}

func ToTerraformSessionRecordingConfigV2(obj *types.SessionRecordingConfigV2, data *schema.ResourceData) error {
	return accessors.ToTerraform(obj, data, SchemaSessionRecordingConfigV2, SchemaMetaSessionRecordingConfigV2)
}
func FromTerraformAuthPreferenceV2(data *schema.ResourceData, obj *types.AuthPreferenceV2) error {
	return accessors.FromTerraform(obj, data, SchemaAuthPreferenceV2, SchemaMetaAuthPreferenceV2)
}

func ToTerraformAuthPreferenceV2(obj *types.AuthPreferenceV2, data *schema.ResourceData) error {
	return accessors.ToTerraform(obj, data, SchemaAuthPreferenceV2, SchemaMetaAuthPreferenceV2)
}
func FromTerraformRoleV4(data *schema.ResourceData, obj *types.RoleV4) error {
	return accessors.FromTerraform(obj, data, SchemaRoleV4, SchemaMetaRoleV4)
}

func ToTerraformRoleV4(obj *types.RoleV4, data *schema.ResourceData) error {
	return accessors.ToTerraform(obj, data, SchemaRoleV4, SchemaMetaRoleV4)
}
func FromTerraformUserV2(data *schema.ResourceData, obj *types.UserV2) error {
	return accessors.FromTerraform(obj, data, SchemaUserV2, SchemaMetaUserV2)
}

func ToTerraformUserV2(obj *types.UserV2, data *schema.ResourceData) error {
	return accessors.ToTerraform(obj, data, SchemaUserV2, SchemaMetaUserV2)
}
func FromTerraformOIDCConnectorV2(data *schema.ResourceData, obj *types.OIDCConnectorV2) error {
	return accessors.FromTerraform(obj, data, SchemaOIDCConnectorV2, SchemaMetaOIDCConnectorV2)
}

func ToTerraformOIDCConnectorV2(obj *types.OIDCConnectorV2, data *schema.ResourceData) error {
	return accessors.ToTerraform(obj, data, SchemaOIDCConnectorV2, SchemaMetaOIDCConnectorV2)
}
func FromTerraformSAMLConnectorV2(data *schema.ResourceData, obj *types.SAMLConnectorV2) error {
	return accessors.FromTerraform(obj, data, SchemaSAMLConnectorV2, SchemaMetaSAMLConnectorV2)
}

func ToTerraformSAMLConnectorV2(obj *types.SAMLConnectorV2, data *schema.ResourceData) error {
	return accessors.ToTerraform(obj, data, SchemaSAMLConnectorV2, SchemaMetaSAMLConnectorV2)
}
func FromTerraformGithubConnectorV3(data *schema.ResourceData, obj *types.GithubConnectorV3) error {
	return accessors.FromTerraform(obj, data, SchemaGithubConnectorV3, SchemaMetaGithubConnectorV3)
}

func ToTerraformGithubConnectorV3(obj *types.GithubConnectorV3, data *schema.ResourceData) error {
	return accessors.ToTerraform(obj, data, SchemaGithubConnectorV3, SchemaMetaGithubConnectorV3)
}
func FromTerraformTrustedClusterV2(data *schema.ResourceData, obj *types.TrustedClusterV2) error {
	return accessors.FromTerraform(obj, data, SchemaTrustedClusterV2, SchemaMetaTrustedClusterV2)
}

func ToTerraformTrustedClusterV2(obj *types.TrustedClusterV2, data *schema.ResourceData) error {
	return accessors.ToTerraform(obj, data, SchemaTrustedClusterV2, SchemaMetaTrustedClusterV2)
}

// SchemaDatabaseV3 returns schema for DatabaseV3
//
// DatabaseV3 represents a single proxied database.
func GenSchemaDatabaseV3() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		// Kind is the database resource kind.
		"kind": {
			Type:        schema.TypeString,
			Description: "Kind is the database resource kind.",
			Optional:    true,
			Computed:    true,
		},
		// SubKind is an optional resource subkind.
		"sub_kind": {
			Type:        schema.TypeString,
			Description: "SubKind is an optional resource subkind.",
			Optional:    true,
		},
		// Version is the resource version.
		"version": {
			Type:        schema.TypeString,
			Description: "Version is the resource version.",
			Optional:    true,
			Computed:    true,
		},
		// Metadata is the database metadata.
		"metadata": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "Metadata is resource metadata",

			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Name is an object name
					"name": {
						Type:        schema.TypeString,
						Description: "Name is an object name",
						Required:    true,
						ForceNew:    true,
					},
					// Namespace is object namespace. The field should be called "namespace"
					// when it returns in Teleport 2.4.
					"namespace": {
						Type:        schema.TypeString,
						Description: "Namespace is object namespace. The field should be called \"namespace\"  when it returns in Teleport 2.4.",
						Optional:    true,
						Computed:    true,
					},
					// Description is object description
					"description": {
						Type:        schema.TypeString,
						Description: "Description is object description",
						Optional:    true,
					},
					// Labels is a set of labels
					"labels": {
						Computed:    true,
						Optional:    true,
						Type:        schema.TypeMap,
						Description: "Labels is a set of labels",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},
					// Expires is a global expiry time header can be set on any resource in the
					// system.
					"expires": {
						Type:         schema.TypeString,
						Description:  "Expires is a global expiry time header can be set on any resource in the  system.",
						ValidateFunc: validation.IsRFC3339Time,
						StateFunc:    TruncateMs,
						Optional:     true,
					},
				},
			},
		},
		// Spec is the database spec.
		"spec": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "DatabaseSpecV3 is the database spec.",

			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Protocol is the database protocol: postgres, mysql, mongodb, etc.
					"protocol": {
						Type:        schema.TypeString,
						Description: "Protocol is the database protocol: postgres, mysql, mongodb, etc.",
						Optional:    true,
					},
					// URI is the database connection endpoint.
					"uri": {
						Type:        schema.TypeString,
						Description: "URI is the database connection endpoint.",
						Optional:    true,
					},
					// CACert is the PEM-encoded database CA certificate.
					"ca_cert": {
						Type:        schema.TypeString,
						Description: "CACert is the PEM-encoded database CA certificate.",
						Optional:    true,
					},
					// DynamicLabels is the database dynamic labels.
					"dynamic_labels": {

						Optional:    true,
						Type:        schema.TypeSet,
						Description: "DynamicLabels is the database dynamic labels.",
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								"key": {
									Type:     schema.TypeString,
									Required: true,
								},
								"value": {
									Type:        schema.TypeList,
									MaxItems:    1,
									Description: "CommandLabelV2 is a label that has a value as a result of the  output generated by running command, e.g. hostname",

									Optional: true,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											// Period is a time between command runs
											"period": {
												Type:             schema.TypeString,
												Description:      "Period is a time between command runs",
												DiffSuppressFunc: SuppressDurationChange,
												Optional:         true,
											},
											// Command is a command to run
											"command": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Command is a command to run",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
											// Result captures standard output
											"result": {
												Type:        schema.TypeString,
												Description: "Result captures standard output",
												Optional:    true,
											},
										},
									},
								},
							},
						},
					},
					// AWS contains AWS specific settings for RDS/Aurora/Redshift databases.
					"aws": {
						Type:        schema.TypeList,
						MaxItems:    1,
						Description: "AWS contains AWS metadata about the database.",

						Optional: true,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// Region is a AWS cloud region.
								"region": {
									Type:        schema.TypeString,
									Description: "Region is a AWS cloud region.",
									Optional:    true,
								},
								// Redshift contains Redshift specific metadata.
								"redshift": {
									Type:        schema.TypeList,
									MaxItems:    1,
									Description: "Redshift contains AWS Redshift specific database metadata.",

									Optional: true,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											// ClusterID is the Redshift cluster identifier.
											"cluster_id": {
												Type:        schema.TypeString,
												Description: "ClusterID is the Redshift cluster identifier.",
												Optional:    true,
											},
										},
									},
								},
								// RDS contains RDS specific metadata.
								"rds": {
									Type:        schema.TypeList,
									MaxItems:    1,
									Description: "RDS contains AWS RDS specific database metadata.",

									Optional: true,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											// InstanceID is the RDS instance identifier.
											"instance_id": {
												Type:        schema.TypeString,
												Description: "InstanceID is the RDS instance identifier.",
												Optional:    true,
											},
											// ClusterID is the RDS cluster (Aurora) identifier.
											"cluster_id": {
												Type:        schema.TypeString,
												Description: "ClusterID is the RDS cluster (Aurora) identifier.",
												Optional:    true,
											},
											// ResourceID is the RDS instance resource identifier (db-xxx).
											"resource_id": {
												Type:        schema.TypeString,
												Description: "ResourceID is the RDS instance resource identifier (db-xxx).",
												Optional:    true,
											},
											// IAMAuth indicates whether database IAM authentication is enabled.
											"iam_auth": {
												Type:        schema.TypeBool,
												Description: "IAMAuth indicates whether database IAM authentication is enabled.",
												Optional:    true,
											},
										},
									},
								},
								// AccountID is the AWS account ID this database belongs to.
								"account_id": {
									Type:        schema.TypeString,
									Description: "AccountID is the AWS account ID this database belongs to.",
									Optional:    true,
								},
							},
						},
					},
					// GCP contains parameters specific to GCP Cloud SQL databases.
					"gcp": {
						Type:        schema.TypeList,
						MaxItems:    1,
						Description: "GCPCloudSQL contains parameters specific to GCP Cloud SQL databases.",

						Optional: true,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// ProjectID is the GCP project ID the Cloud SQL instance resides in.
								"project_id": {
									Type:        schema.TypeString,
									Description: "ProjectID is the GCP project ID the Cloud SQL instance resides in.",
									Optional:    true,
								},
								// InstanceID is the Cloud SQL instance ID.
								"instance_id": {
									Type:        schema.TypeString,
									Description: "InstanceID is the Cloud SQL instance ID.",
									Optional:    true,
								},
							},
						},
					},
				},
			},
		},
	}
}

// GenSchemaMetaDatabaseV3 returns schema for DatabaseV3
//
// DatabaseV3 represents a single proxied database.
func GenSchemaMetaDatabaseV3() map[string]*accessors.SchemaMeta {
	return map[string]*accessors.SchemaMeta{
		// Kind is the database resource kind.
		"kind": {
			Name:       "Kind",
			IsTime:     false,
			IsDuration: false,
		},
		// SubKind is an optional resource subkind.
		"sub_kind": {
			Name:       "SubKind",
			IsTime:     false,
			IsDuration: false,
		},
		// Version is the resource version.
		"version": {
			Name:       "Version",
			IsTime:     false,
			IsDuration: false,
		},
		// Metadata is the database metadata.
		"metadata": {
			Name:       "Metadata",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Name is an object name
				"name": {
					Name:       "Name",
					IsTime:     false,
					IsDuration: false,
				},
				// Namespace is object namespace. The field should be called "namespace"
				// when it returns in Teleport 2.4.
				"namespace": {
					Name:       "Namespace",
					IsTime:     false,
					IsDuration: false,
				},
				// Description is object description
				"description": {
					Name:       "Description",
					IsTime:     false,
					IsDuration: false,
				},
				// Labels is a set of labels
				"labels": {
					Name:       "Labels",
					IsTime:     false,
					IsDuration: false,
				},
				// Expires is a global expiry time header can be set on any resource in the
				// system.
				"expires": {
					Name:       "Expires",
					IsTime:     true,
					IsDuration: false,
				},
			},
		},
		// Spec is the database spec.
		"spec": {
			Name:       "Spec",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Protocol is the database protocol: postgres, mysql, mongodb, etc.
				"protocol": {
					Name:       "Protocol",
					IsTime:     false,
					IsDuration: false,
				},
				// URI is the database connection endpoint.
				"uri": {
					Name:       "URI",
					IsTime:     false,
					IsDuration: false,
				},
				// CACert is the PEM-encoded database CA certificate.
				"ca_cert": {
					Name:       "CACert",
					IsTime:     false,
					IsDuration: false,
				},
				// DynamicLabels is the database dynamic labels.
				"dynamic_labels": {
					Name:       "DynamicLabels",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// Period is a time between command runs
						"period": {
							Name:       "Period",
							IsTime:     false,
							IsDuration: true,
						},
						// Command is a command to run
						"command": {
							Name:       "Command",
							IsTime:     false,
							IsDuration: false,
						},
						// Result captures standard output
						"result": {
							Name:       "Result",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
				// AWS contains AWS specific settings for RDS/Aurora/Redshift databases.
				"aws": {
					Name:       "AWS",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// Region is a AWS cloud region.
						"region": {
							Name:       "Region",
							IsTime:     false,
							IsDuration: false,
						},
						// Redshift contains Redshift specific metadata.
						"redshift": {
							Name:       "Redshift",
							IsTime:     false,
							IsDuration: false,
							Nested: map[string]*accessors.SchemaMeta{
								// ClusterID is the Redshift cluster identifier.
								"cluster_id": {
									Name:       "ClusterID",
									IsTime:     false,
									IsDuration: false,
								},
							},
						},
						// RDS contains RDS specific metadata.
						"rds": {
							Name:       "RDS",
							IsTime:     false,
							IsDuration: false,
							Nested: map[string]*accessors.SchemaMeta{
								// InstanceID is the RDS instance identifier.
								"instance_id": {
									Name:       "InstanceID",
									IsTime:     false,
									IsDuration: false,
								},
								// ClusterID is the RDS cluster (Aurora) identifier.
								"cluster_id": {
									Name:       "ClusterID",
									IsTime:     false,
									IsDuration: false,
								},
								// ResourceID is the RDS instance resource identifier (db-xxx).
								"resource_id": {
									Name:       "ResourceID",
									IsTime:     false,
									IsDuration: false,
								},
								// IAMAuth indicates whether database IAM authentication is enabled.
								"iam_auth": {
									Name:       "IAMAuth",
									IsTime:     false,
									IsDuration: false,
								},
							},
						},
						// AccountID is the AWS account ID this database belongs to.
						"account_id": {
							Name:       "AccountID",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
				// GCP contains parameters specific to GCP Cloud SQL databases.
				"gcp": {
					Name:       "GCP",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// ProjectID is the GCP project ID the Cloud SQL instance resides in.
						"project_id": {
							Name:       "ProjectID",
							IsTime:     false,
							IsDuration: false,
						},
						// InstanceID is the Cloud SQL instance ID.
						"instance_id": {
							Name:       "InstanceID",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
			},
		},
	}
}

// SchemaAppV3 returns schema for AppV3
//
// AppV3 represents an app resource.
func GenSchemaAppV3() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		// Kind is the app resource kind. Always "app".
		"kind": {
			Type:        schema.TypeString,
			Description: "Kind is the app resource kind. Always \"app\".",
			Optional:    true,
			Computed:    true,
		},
		// SubKind is an optional resource subkind.
		"sub_kind": {
			Type:        schema.TypeString,
			Description: "SubKind is an optional resource subkind.",
			Optional:    true,
		},
		// Version is the resource version.
		"version": {
			Type:        schema.TypeString,
			Description: "Version is the resource version.",
			Optional:    true,
			Computed:    true,
		},
		// Metadata is the app resource metadata.
		"metadata": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "Metadata is resource metadata",

			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Name is an object name
					"name": {
						Type:        schema.TypeString,
						Description: "Name is an object name",
						Required:    true,
						ForceNew:    true,
					},
					// Namespace is object namespace. The field should be called "namespace"
					// when it returns in Teleport 2.4.
					"namespace": {
						Type:        schema.TypeString,
						Description: "Namespace is object namespace. The field should be called \"namespace\"  when it returns in Teleport 2.4.",
						Optional:    true,
						Computed:    true,
					},
					// Description is object description
					"description": {
						Type:        schema.TypeString,
						Description: "Description is object description",
						Optional:    true,
					},
					// Labels is a set of labels
					"labels": {

						Optional:    true,
						Type:        schema.TypeMap,
						Description: "Labels is a set of labels",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},
					// Expires is a global expiry time header can be set on any resource in the
					// system.
					"expires": {
						Type:         schema.TypeString,
						Description:  "Expires is a global expiry time header can be set on any resource in the  system.",
						ValidateFunc: validation.IsRFC3339Time,
						StateFunc:    TruncateMs,
						Optional:     true,
					},
				},
			},
		},
		// Spec is the app resource spec.
		"spec": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "AppSpecV3 is the AppV3 resource spec.",

			Required: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// URI is the web app endpoint.
					"uri": {
						Type:        schema.TypeString,
						Description: "URI is the web app endpoint.",
						Required:    true,
					},
					// PublicAddr is the public address the application is accessible at.
					"public_addr": {
						Type:        schema.TypeString,
						Description: "PublicAddr is the public address the application is accessible at.",
						Optional:    true,
					},
					// DynamicLabels are the app's command labels.
					"dynamic_labels": {

						Optional:    true,
						Type:        schema.TypeSet,
						Description: "DynamicLabels are the app's command labels.",
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								"key": {
									Type:     schema.TypeString,
									Required: true,
								},
								"value": {
									Type:        schema.TypeList,
									MaxItems:    1,
									Description: "CommandLabelV2 is a label that has a value as a result of the  output generated by running command, e.g. hostname",

									Optional: true,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											// Period is a time between command runs
											"period": {
												Type:             schema.TypeString,
												Description:      "Period is a time between command runs",
												DiffSuppressFunc: SuppressDurationChange,
												Optional:         true,
											},
											// Command is a command to run
											"command": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Command is a command to run",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
											// Result captures standard output
											"result": {
												Type:        schema.TypeString,
												Description: "Result captures standard output",
												Optional:    true,
											},
										},
									},
								},
							},
						},
					},
					// InsecureSkipVerify disables app's TLS certificate verification.
					"insecure_skip_verify": {
						Type:        schema.TypeBool,
						Description: "InsecureSkipVerify disables app's TLS certificate verification.",
						Optional:    true,
					},
					// Rewrite is a list of rewriting rules to apply to requests and responses.
					"rewrite": {
						Type:        schema.TypeList,
						MaxItems:    1,
						Description: "Rewrite is a list of rewriting rules to apply to requests and responses.",

						Optional: true,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// Redirect defines a list of hosts which will be rewritten to the public
								// address of the application if they occur in the "Location" header.
								"redirect": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "Redirect defines a list of hosts which will be rewritten to the public  address of the application if they occur in the \"Location\" header.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
								// Headers is a list of headers to inject when passing the request over
								// to the application.
								"headers": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "Headers is a list of headers to inject when passing the request over  to the application.",
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											// Name is the http header name.
											"name": {
												Type:        schema.TypeString,
												Description: "Name is the http header name.",
												Optional:    true,
											},
											// Value is the http header value.
											"value": {
												Type:        schema.TypeString,
												Description: "Value is the http header value.",
												Optional:    true,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// GenSchemaMetaAppV3 returns schema for AppV3
//
// AppV3 represents an app resource.
func GenSchemaMetaAppV3() map[string]*accessors.SchemaMeta {
	return map[string]*accessors.SchemaMeta{
		// Kind is the app resource kind. Always "app".
		"kind": {
			Name:       "Kind",
			IsTime:     false,
			IsDuration: false,
		},
		// SubKind is an optional resource subkind.
		"sub_kind": {
			Name:       "SubKind",
			IsTime:     false,
			IsDuration: false,
		},
		// Version is the resource version.
		"version": {
			Name:       "Version",
			IsTime:     false,
			IsDuration: false,
		},
		// Metadata is the app resource metadata.
		"metadata": {
			Name:       "Metadata",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Name is an object name
				"name": {
					Name:       "Name",
					IsTime:     false,
					IsDuration: false,
				},
				// Namespace is object namespace. The field should be called "namespace"
				// when it returns in Teleport 2.4.
				"namespace": {
					Name:       "Namespace",
					IsTime:     false,
					IsDuration: false,
				},
				// Description is object description
				"description": {
					Name:       "Description",
					IsTime:     false,
					IsDuration: false,
				},
				// Labels is a set of labels
				"labels": {
					Name:       "Labels",
					IsTime:     false,
					IsDuration: false,
				},
				// Expires is a global expiry time header can be set on any resource in the
				// system.
				"expires": {
					Name:       "Expires",
					IsTime:     true,
					IsDuration: false,
				},
			},
		},
		// Spec is the app resource spec.
		"spec": {
			Name:       "Spec",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// URI is the web app endpoint.
				"uri": {
					Name:       "URI",
					IsTime:     false,
					IsDuration: false,
				},
				// PublicAddr is the public address the application is accessible at.
				"public_addr": {
					Name:       "PublicAddr",
					IsTime:     false,
					IsDuration: false,
				},
				// DynamicLabels are the app's command labels.
				"dynamic_labels": {
					Name:       "DynamicLabels",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// Period is a time between command runs
						"period": {
							Name:       "Period",
							IsTime:     false,
							IsDuration: true,
						},
						// Command is a command to run
						"command": {
							Name:       "Command",
							IsTime:     false,
							IsDuration: false,
						},
						// Result captures standard output
						"result": {
							Name:       "Result",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
				// InsecureSkipVerify disables app's TLS certificate verification.
				"insecure_skip_verify": {
					Name:       "InsecureSkipVerify",
					IsTime:     false,
					IsDuration: false,
				},
				// Rewrite is a list of rewriting rules to apply to requests and responses.
				"rewrite": {
					Name:       "Rewrite",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// Redirect defines a list of hosts which will be rewritten to the public
						// address of the application if they occur in the "Location" header.
						"redirect": {
							Name:       "Redirect",
							IsTime:     false,
							IsDuration: false,
						},
						// Headers is a list of headers to inject when passing the request over
						// to the application.
						"headers": {
							Name:       "Headers",
							IsTime:     false,
							IsDuration: false,
							Nested: map[string]*accessors.SchemaMeta{
								// Name is the http header name.
								"name": {
									Name:       "Name",
									IsTime:     false,
									IsDuration: false,
								},
								// Value is the http header value.
								"value": {
									Name:       "Value",
									IsTime:     false,
									IsDuration: false,
								},
							},
						},
					},
				},
			},
		},
	}
}

// SchemaProvisionTokenV2 returns schema for ProvisionTokenV2
//
// ProvisionTokenV2 specifies provisioning token
func GenSchemaProvisionTokenV2() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		// Kind is a resource kind
		"kind": {
			Type:        schema.TypeString,
			Description: "Kind is a resource kind",
			Optional:    true,
			Computed:    true,
		},
		// SubKind is an optional resource sub kind, used in some resources
		"sub_kind": {
			Type:        schema.TypeString,
			Description: "SubKind is an optional resource sub kind, used in some resources",
			Optional:    true,
		},
		// Version is version
		"version": {
			Type:        schema.TypeString,
			Description: "Version is version",
			Optional:    true,
			Computed:    true,
		},
		// Metadata is resource metadata
		"metadata": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "Metadata is resource metadata",

			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Name is an object name
					"name": {
						Type:        schema.TypeString,
						Description: "Name is an object name",
						Required:    true,
						ForceNew:    true,
						Sensitive:   true,
					},
					// Namespace is object namespace. The field should be called "namespace"
					// when it returns in Teleport 2.4.
					"namespace": {
						Type:        schema.TypeString,
						Description: "Namespace is object namespace. The field should be called \"namespace\"  when it returns in Teleport 2.4.",
						Optional:    true,
						Computed:    true,
					},
					// Description is object description
					"description": {
						Type:        schema.TypeString,
						Description: "Description is object description",
						Optional:    true,
					},
					// Labels is a set of labels
					"labels": {

						Optional:    true,
						Type:        schema.TypeMap,
						Description: "Labels is a set of labels",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},
					// Expires is a global expiry time header can be set on any resource in the
					// system.
					"expires": {
						Type:         schema.TypeString,
						Description:  "Expires is a global expiry time header can be set on any resource in the  system.",
						ValidateFunc: validation.IsRFC3339Time,
						StateFunc:    TruncateMs,
						Required:     true,
					},
				},
			},
		},
		// Spec is a provisioning token V2 spec
		"spec": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "ProvisionTokenSpecV2 is a specification for V2 token",

			Required: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Roles is a list of roles associated with the token,
					// that will be converted to metadata in the SSH and X509
					// certificates issued to the user of the token
					"roles": {

						Required:    true,
						Type:        schema.TypeList,
						Description: "Roles is a list of roles associated with the token,  that will be converted to metadata in the SSH and X509  certificates issued to the user of the token",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},

					"allow": {

						Optional:    true,
						Type:        schema.TypeList,
						Description: "",
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{

								"aws_account": {
									Type:        schema.TypeString,
									Description: "",
									Optional:    true,
								},

								"aws_regions": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},

								"aws_role": {
									Type:        schema.TypeString,
									Description: "",
									Optional:    true,
								},
							},
						},
					},

					"aws_iid_ttl": {
						Type:             schema.TypeString,
						Description:      "",
						DiffSuppressFunc: SuppressDurationChange,
						Optional:         true,
						Computed:         true,
					},
				},
			},
		},
	}
}

// GenSchemaMetaProvisionTokenV2 returns schema for ProvisionTokenV2
//
// ProvisionTokenV2 specifies provisioning token
func GenSchemaMetaProvisionTokenV2() map[string]*accessors.SchemaMeta {
	return map[string]*accessors.SchemaMeta{
		// Kind is a resource kind
		"kind": {
			Name:       "Kind",
			IsTime:     false,
			IsDuration: false,
		},
		// SubKind is an optional resource sub kind, used in some resources
		"sub_kind": {
			Name:       "SubKind",
			IsTime:     false,
			IsDuration: false,
		},
		// Version is version
		"version": {
			Name:       "Version",
			IsTime:     false,
			IsDuration: false,
		},
		// Metadata is resource metadata
		"metadata": {
			Name:       "Metadata",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Name is an object name
				"name": {
					Name:       "Name",
					IsTime:     false,
					IsDuration: false,
				},
				// Namespace is object namespace. The field should be called "namespace"
				// when it returns in Teleport 2.4.
				"namespace": {
					Name:       "Namespace",
					IsTime:     false,
					IsDuration: false,
				},
				// Description is object description
				"description": {
					Name:       "Description",
					IsTime:     false,
					IsDuration: false,
				},
				// Labels is a set of labels
				"labels": {
					Name:       "Labels",
					IsTime:     false,
					IsDuration: false,
				},
				// Expires is a global expiry time header can be set on any resource in the
				// system.
				"expires": {
					Name:       "Expires",
					IsTime:     true,
					IsDuration: false,
				},
			},
		},
		// Spec is a provisioning token V2 spec
		"spec": {
			Name:       "Spec",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Roles is a list of roles associated with the token,
				// that will be converted to metadata in the SSH and X509
				// certificates issued to the user of the token
				"roles": {
					Name:       "Roles",
					IsTime:     false,
					IsDuration: false,
				},

				"allow": {
					Name:       "Allow",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{

						"aws_account": {
							Name:       "AWSAccount",
							IsTime:     false,
							IsDuration: false,
						},

						"aws_regions": {
							Name:       "AWSRegions",
							IsTime:     false,
							IsDuration: false,
						},

						"aws_role": {
							Name:       "AWSRole",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},

				"aws_iid_ttl": {
					Name:       "AWSIIDTTL",
					IsTime:     false,
					IsDuration: true,
				},
			},
		},
	}
}

// SchemaClusterAuditConfigV2 returns schema for ClusterAuditConfigV2
//
// ClusterAuditConfigV2 represents audit log settings in the cluster.
func GenSchemaClusterAuditConfigV2() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		// Kind is a resource kind
		"kind": {
			Type:        schema.TypeString,
			Description: "Kind is a resource kind",
			Optional:    true,
			Computed:    true,
		},
		// SubKind is an optional resource sub kind, used in some resources
		"sub_kind": {
			Type:        schema.TypeString,
			Description: "SubKind is an optional resource sub kind, used in some resources",
			Optional:    true,
		},
		// Version is a resource version
		"version": {
			Type:        schema.TypeString,
			Description: "Version is a resource version",
			Optional:    true,
			Computed:    true,
		},
		// Metadata is resource metadata
		"metadata": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "Metadata is resource metadata",

			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Namespace is object namespace. The field should be called "namespace"
					// when it returns in Teleport 2.4.
					"namespace": {
						Type:        schema.TypeString,
						Description: "Namespace is object namespace. The field should be called \"namespace\"  when it returns in Teleport 2.4.",
						Optional:    true,
						Computed:    true,
					},
					// Description is object description
					"description": {
						Type:        schema.TypeString,
						Description: "Description is object description",
						Optional:    true,
					},
					// Labels is a set of labels
					"labels": {

						Optional:    true,
						Type:        schema.TypeMap,
						Description: "Labels is a set of labels",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},
					// Expires is a global expiry time header can be set on any resource in the
					// system.
					"expires": {
						Type:         schema.TypeString,
						Description:  "Expires is a global expiry time header can be set on any resource in the  system.",
						ValidateFunc: validation.IsRFC3339Time,
						StateFunc:    TruncateMs,
						Optional:     true,
					},
				},
			},
		},
		// Spec is a ClusterAuditConfig specification
		"spec": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "ClusterAuditConfigSpecV2 is the actual data we care about  for ClusterAuditConfig.",

			Required: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Type is audit backend type
					"type": {
						Type:        schema.TypeString,
						Description: "Type is audit backend type",
						Optional:    true,
					},
					// Region is a region setting for audit sessions used by cloud providers
					"region": {
						Type:        schema.TypeString,
						Description: "Region is a region setting for audit sessions used by cloud providers",
						Optional:    true,
					},
					// AuditSessionsURI is a parameter where to upload sessions
					"audit_sessions_uri": {
						Type:        schema.TypeString,
						Description: "AuditSessionsURI is a parameter where to upload sessions",
						Optional:    true,
					},
					// AuditEventsURI is a parameter with all supported outputs
					// for audit events
					"audit_events_uri": SchemaStrings(),
					// EnableContinuousBackups is used to enable (or disable) PITR (Point-In-Time Recovery).
					"continuous_backups": {
						Type:        schema.TypeBool,
						Description: "EnableContinuousBackups is used to enable (or disable) PITR (Point-In-Time Recovery).",
						Optional:    true,
					},
					// EnableAutoScaling is used to enable (or disable) auto scaling policy.
					"auto_scaling": {
						Type:        schema.TypeBool,
						Description: "EnableAutoScaling is used to enable (or disable) auto scaling policy.",
						Optional:    true,
					},
					// ReadMaxCapacity is the maximum provisioned read capacity.
					"read_max_capacity": {
						Type:        schema.TypeInt,
						Description: "ReadMaxCapacity is the maximum provisioned read capacity.",
						Optional:    true,
					},
					// ReadMinCapacity is the minimum provisioned read capacity.
					"read_min_capacity": {
						Type:        schema.TypeInt,
						Description: "ReadMinCapacity is the minimum provisioned read capacity.",
						Optional:    true,
					},
					// ReadTargetValue is the ratio of consumed read to provisioned capacity.
					"read_target_value": {
						Type:        schema.TypeFloat,
						Description: "ReadTargetValue is the ratio of consumed read to provisioned capacity.",
						Optional:    true,
					},
					// WriteMaxCapacity is the maximum provisioned write capacity.
					"write_max_capacity": {
						Type:        schema.TypeInt,
						Description: "WriteMaxCapacity is the maximum provisioned write capacity.",
						Optional:    true,
					},
					// WriteMinCapacity is the minimum provisioned write capacity.
					"write_min_capacity": {
						Type:        schema.TypeInt,
						Description: "WriteMinCapacity is the minimum provisioned write capacity.",
						Optional:    true,
					},
					// WriteTargetValue is the ratio of consumed write to provisioned capacity.
					"write_target_value": {
						Type:        schema.TypeFloat,
						Description: "WriteTargetValue is the ratio of consumed write to provisioned capacity.",
						Optional:    true,
					},
				},
			},
		},
	}
}

// GenSchemaMetaClusterAuditConfigV2 returns schema for ClusterAuditConfigV2
//
// ClusterAuditConfigV2 represents audit log settings in the cluster.
func GenSchemaMetaClusterAuditConfigV2() map[string]*accessors.SchemaMeta {
	return map[string]*accessors.SchemaMeta{
		// Kind is a resource kind
		"kind": {
			Name:       "Kind",
			IsTime:     false,
			IsDuration: false,
		},
		// SubKind is an optional resource sub kind, used in some resources
		"sub_kind": {
			Name:       "SubKind",
			IsTime:     false,
			IsDuration: false,
		},
		// Version is a resource version
		"version": {
			Name:       "Version",
			IsTime:     false,
			IsDuration: false,
		},
		// Metadata is resource metadata
		"metadata": {
			Name:       "Metadata",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Namespace is object namespace. The field should be called "namespace"
				// when it returns in Teleport 2.4.
				"namespace": {
					Name:       "Namespace",
					IsTime:     false,
					IsDuration: false,
				},
				// Description is object description
				"description": {
					Name:       "Description",
					IsTime:     false,
					IsDuration: false,
				},
				// Labels is a set of labels
				"labels": {
					Name:       "Labels",
					IsTime:     false,
					IsDuration: false,
				},
				// Expires is a global expiry time header can be set on any resource in the
				// system.
				"expires": {
					Name:       "Expires",
					IsTime:     true,
					IsDuration: false,
				},
			},
		},
		// Spec is a ClusterAuditConfig specification
		"spec": {
			Name:       "Spec",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Type is audit backend type
				"type": {
					Name:       "Type",
					IsTime:     false,
					IsDuration: false,
				},
				// Region is a region setting for audit sessions used by cloud providers
				"region": {
					Name:       "Region",
					IsTime:     false,
					IsDuration: false,
				},
				// AuditSessionsURI is a parameter where to upload sessions
				"audit_sessions_uri": {
					Name:       "AuditSessionsURI",
					IsTime:     false,
					IsDuration: false,
				},
				// AuditEventsURI is a parameter with all supported outputs
				// for audit events
				"audit_events_uri": {
					Name:          "AuditEventsURI",
					IsTime:        false,
					IsDuration:    false,
					FromTerraform: FromTerraformStrings,
					ToTerraform:   ToTerraformStrings,
				},
				// EnableContinuousBackups is used to enable (or disable) PITR (Point-In-Time Recovery).
				"continuous_backups": {
					Name:       "EnableContinuousBackups",
					IsTime:     false,
					IsDuration: false,
				},
				// EnableAutoScaling is used to enable (or disable) auto scaling policy.
				"auto_scaling": {
					Name:       "EnableAutoScaling",
					IsTime:     false,
					IsDuration: false,
				},
				// ReadMaxCapacity is the maximum provisioned read capacity.
				"read_max_capacity": {
					Name:       "ReadMaxCapacity",
					IsTime:     false,
					IsDuration: false,
				},
				// ReadMinCapacity is the minimum provisioned read capacity.
				"read_min_capacity": {
					Name:       "ReadMinCapacity",
					IsTime:     false,
					IsDuration: false,
				},
				// ReadTargetValue is the ratio of consumed read to provisioned capacity.
				"read_target_value": {
					Name:       "ReadTargetValue",
					IsTime:     false,
					IsDuration: false,
				},
				// WriteMaxCapacity is the maximum provisioned write capacity.
				"write_max_capacity": {
					Name:       "WriteMaxCapacity",
					IsTime:     false,
					IsDuration: false,
				},
				// WriteMinCapacity is the minimum provisioned write capacity.
				"write_min_capacity": {
					Name:       "WriteMinCapacity",
					IsTime:     false,
					IsDuration: false,
				},
				// WriteTargetValue is the ratio of consumed write to provisioned capacity.
				"write_target_value": {
					Name:       "WriteTargetValue",
					IsTime:     false,
					IsDuration: false,
				},
			},
		},
	}
}

// SchemaClusterNetworkingConfigV2 returns schema for ClusterNetworkingConfigV2
//
// ClusterNetworkingConfigV2 contains cluster-wide networking configuration.
func GenSchemaClusterNetworkingConfigV2() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		// Kind is a resource kind
		"kind": {
			Type:        schema.TypeString,
			Description: "Kind is a resource kind",
			Optional:    true,
			Computed:    true,
		},
		// SubKind is an optional resource sub kind, used in some resources
		"sub_kind": {
			Type:        schema.TypeString,
			Description: "SubKind is an optional resource sub kind, used in some resources",
			Optional:    true,
		},
		// Version is a resource version
		"version": {
			Type:        schema.TypeString,
			Description: "Version is a resource version",
			Optional:    true,
			Computed:    true,
		},
		// Metadata is resource metadata
		"metadata": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "Metadata is resource metadata",

			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Namespace is object namespace. The field should be called "namespace"
					// when it returns in Teleport 2.4.
					"namespace": {
						Type:        schema.TypeString,
						Description: "Namespace is object namespace. The field should be called \"namespace\"  when it returns in Teleport 2.4.",
						Optional:    true,
						Computed:    true,
					},
					// Description is object description
					"description": {
						Type:        schema.TypeString,
						Description: "Description is object description",
						Optional:    true,
					},
					// Labels is a set of labels
					"labels": {

						Optional:    true,
						Type:        schema.TypeMap,
						Description: "Labels is a set of labels",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},
					// Expires is a global expiry time header can be set on any resource in the
					// system.
					"expires": {
						Type:         schema.TypeString,
						Description:  "Expires is a global expiry time header can be set on any resource in the  system.",
						ValidateFunc: validation.IsRFC3339Time,
						StateFunc:    TruncateMs,
						Optional:     true,
					},
				},
			},
		},
		// Spec is a ClusterNetworkingConfig specification
		"spec": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "ClusterNetworkingConfigSpecV2 is the actual data we care about  for ClusterNetworkingConfig.",

			Required: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// ClientIdleTimeout sets global cluster default setting for client idle
					// timeouts.
					"client_idle_timeout": {
						Type:             schema.TypeString,
						Description:      "ClientIdleTimeout sets global cluster default setting for client idle  timeouts.",
						DiffSuppressFunc: SuppressDurationChange,
						Optional:         true,
					},
					// KeepAliveInterval is the interval at which the server sends keep-alive messsages
					// to the client.
					"keep_alive_interval": {
						Type:             schema.TypeString,
						Description:      "KeepAliveInterval is the interval at which the server sends keep-alive messsages  to the client.",
						DiffSuppressFunc: SuppressDurationChange,
						Optional:         true,
						Computed:         true,
					},
					// KeepAliveCountMax is the number of keep-alive messages that can be
					// missed before the server disconnects the connection to the client.
					"keep_alive_count_max": {
						Type:        schema.TypeInt,
						Description: "KeepAliveCountMax is the number of keep-alive messages that can be  missed before the server disconnects the connection to the client.",
						Optional:    true,
						Computed:    true,
					},
					// SessionControlTimeout is the session control lease expiry and defines
					// the upper limit of how long a node may be out of contact with the auth
					// server before it begins terminating controlled sessions.
					"session_control_timeout": {
						Type:             schema.TypeString,
						Description:      "SessionControlTimeout is the session control lease expiry and defines  the upper limit of how long a node may be out of contact with the auth  server before it begins terminating controlled sessions.",
						DiffSuppressFunc: SuppressDurationChange,
						Optional:         true,
					},
					// ClientIdleTimeoutMessage is the message sent to the user when a connection times out.
					"idle_timeout_message": {
						Type:        schema.TypeString,
						Description: "ClientIdleTimeoutMessage is the message sent to the user when a connection times out.",
						Optional:    true,
					},
					// WebIdleTimeout sets global cluster default setting for the web UI idle
					// timeouts.
					"web_idle_timeout": {
						Type:             schema.TypeString,
						Description:      "WebIdleTimeout sets global cluster default setting for the web UI idle  timeouts.",
						DiffSuppressFunc: SuppressDurationChange,
						Optional:         true,
					},
				},
			},
		},
	}
}

// GenSchemaMetaClusterNetworkingConfigV2 returns schema for ClusterNetworkingConfigV2
//
// ClusterNetworkingConfigV2 contains cluster-wide networking configuration.
func GenSchemaMetaClusterNetworkingConfigV2() map[string]*accessors.SchemaMeta {
	return map[string]*accessors.SchemaMeta{
		// Kind is a resource kind
		"kind": {
			Name:       "Kind",
			IsTime:     false,
			IsDuration: false,
		},
		// SubKind is an optional resource sub kind, used in some resources
		"sub_kind": {
			Name:       "SubKind",
			IsTime:     false,
			IsDuration: false,
		},
		// Version is a resource version
		"version": {
			Name:       "Version",
			IsTime:     false,
			IsDuration: false,
		},
		// Metadata is resource metadata
		"metadata": {
			Name:       "Metadata",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Namespace is object namespace. The field should be called "namespace"
				// when it returns in Teleport 2.4.
				"namespace": {
					Name:       "Namespace",
					IsTime:     false,
					IsDuration: false,
				},
				// Description is object description
				"description": {
					Name:       "Description",
					IsTime:     false,
					IsDuration: false,
				},
				// Labels is a set of labels
				"labels": {
					Name:       "Labels",
					IsTime:     false,
					IsDuration: false,
				},
				// Expires is a global expiry time header can be set on any resource in the
				// system.
				"expires": {
					Name:       "Expires",
					IsTime:     true,
					IsDuration: false,
				},
			},
		},
		// Spec is a ClusterNetworkingConfig specification
		"spec": {
			Name:       "Spec",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// ClientIdleTimeout sets global cluster default setting for client idle
				// timeouts.
				"client_idle_timeout": {
					Name:       "ClientIdleTimeout",
					IsTime:     false,
					IsDuration: true,
				},
				// KeepAliveInterval is the interval at which the server sends keep-alive messsages
				// to the client.
				"keep_alive_interval": {
					Name:       "KeepAliveInterval",
					IsTime:     false,
					IsDuration: true,
				},
				// KeepAliveCountMax is the number of keep-alive messages that can be
				// missed before the server disconnects the connection to the client.
				"keep_alive_count_max": {
					Name:       "KeepAliveCountMax",
					IsTime:     false,
					IsDuration: false,
				},
				// SessionControlTimeout is the session control lease expiry and defines
				// the upper limit of how long a node may be out of contact with the auth
				// server before it begins terminating controlled sessions.
				"session_control_timeout": {
					Name:       "SessionControlTimeout",
					IsTime:     false,
					IsDuration: true,
				},
				// ClientIdleTimeoutMessage is the message sent to the user when a connection times out.
				"idle_timeout_message": {
					Name:       "ClientIdleTimeoutMessage",
					IsTime:     false,
					IsDuration: false,
				},
				// WebIdleTimeout sets global cluster default setting for the web UI idle
				// timeouts.
				"web_idle_timeout": {
					Name:       "WebIdleTimeout",
					IsTime:     false,
					IsDuration: true,
				},
			},
		},
	}
}

// SchemaSessionRecordingConfigV2 returns schema for SessionRecordingConfigV2
//
// SessionRecordingConfigV2 contains session recording configuration.
func GenSchemaSessionRecordingConfigV2() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		// Kind is a resource kind
		"kind": {
			Type:        schema.TypeString,
			Description: "Kind is a resource kind",
			Optional:    true,
			Computed:    true,
		},
		// SubKind is an optional resource sub kind, used in some resources
		"sub_kind": {
			Type:        schema.TypeString,
			Description: "SubKind is an optional resource sub kind, used in some resources",
			Optional:    true,
		},
		// Version is a resource version
		"version": {
			Type:        schema.TypeString,
			Description: "Version is a resource version",
			Optional:    true,
			Computed:    true,
		},
		// Metadata is resource metadata
		"metadata": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "Metadata is resource metadata",

			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Namespace is object namespace. The field should be called "namespace"
					// when it returns in Teleport 2.4.
					"namespace": {
						Type:        schema.TypeString,
						Description: "Namespace is object namespace. The field should be called \"namespace\"  when it returns in Teleport 2.4.",
						Optional:    true,
						Computed:    true,
					},
					// Description is object description
					"description": {
						Type:        schema.TypeString,
						Description: "Description is object description",
						Optional:    true,
					},
					// Labels is a set of labels
					"labels": {

						Optional:    true,
						Type:        schema.TypeMap,
						Description: "Labels is a set of labels",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},
					// Expires is a global expiry time header can be set on any resource in the
					// system.
					"expires": {
						Type:         schema.TypeString,
						Description:  "Expires is a global expiry time header can be set on any resource in the  system.",
						ValidateFunc: validation.IsRFC3339Time,
						StateFunc:    TruncateMs,
						Optional:     true,
					},
				},
			},
		},
		// Spec is a SessionRecordingConfig specification
		"spec": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "SessionRecordingConfigSpecV2 is the actual data we care about  for SessionRecordingConfig.",

			Required: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Mode controls where (or if) the session is recorded.
					"mode": {
						Type:        schema.TypeString,
						Description: "Mode controls where (or if) the session is recorded.",
						Optional:    true,
						Computed:    true,
					},
					// ProxyChecksHostKeys is used to control if the proxy will check host keys
					// when in recording mode.
					"proxy_checks_host_keys": SchemaBoolOption(),
				},
			},
		},
	}
}

// GenSchemaMetaSessionRecordingConfigV2 returns schema for SessionRecordingConfigV2
//
// SessionRecordingConfigV2 contains session recording configuration.
func GenSchemaMetaSessionRecordingConfigV2() map[string]*accessors.SchemaMeta {
	return map[string]*accessors.SchemaMeta{
		// Kind is a resource kind
		"kind": {
			Name:       "Kind",
			IsTime:     false,
			IsDuration: false,
		},
		// SubKind is an optional resource sub kind, used in some resources
		"sub_kind": {
			Name:       "SubKind",
			IsTime:     false,
			IsDuration: false,
		},
		// Version is a resource version
		"version": {
			Name:       "Version",
			IsTime:     false,
			IsDuration: false,
		},
		// Metadata is resource metadata
		"metadata": {
			Name:       "Metadata",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Namespace is object namespace. The field should be called "namespace"
				// when it returns in Teleport 2.4.
				"namespace": {
					Name:       "Namespace",
					IsTime:     false,
					IsDuration: false,
				},
				// Description is object description
				"description": {
					Name:       "Description",
					IsTime:     false,
					IsDuration: false,
				},
				// Labels is a set of labels
				"labels": {
					Name:       "Labels",
					IsTime:     false,
					IsDuration: false,
				},
				// Expires is a global expiry time header can be set on any resource in the
				// system.
				"expires": {
					Name:       "Expires",
					IsTime:     true,
					IsDuration: false,
				},
			},
		},
		// Spec is a SessionRecordingConfig specification
		"spec": {
			Name:       "Spec",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Mode controls where (or if) the session is recorded.
				"mode": {
					Name:       "Mode",
					IsTime:     false,
					IsDuration: false,
				},
				// ProxyChecksHostKeys is used to control if the proxy will check host keys
				// when in recording mode.
				"proxy_checks_host_keys": {
					Name:          "ProxyChecksHostKeys",
					IsTime:        false,
					IsDuration:    false,
					FromTerraform: FromTerraformBoolOption,
					ToTerraform:   ToTerraformBoolOption,
				},
			},
		},
	}
}

// SchemaAuthPreferenceV2 returns schema for AuthPreferenceV2
//
// AuthPreferenceV2 implements the AuthPreference interface.
func GenSchemaAuthPreferenceV2() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		// Kind is a resource kind
		"kind": {
			Type:        schema.TypeString,
			Description: "Kind is a resource kind",
			Optional:    true,
			Computed:    true,
		},
		// SubKind is an optional resource sub kind, used in some resources
		"sub_kind": {
			Type:        schema.TypeString,
			Description: "SubKind is an optional resource sub kind, used in some resources",
			Optional:    true,
		},
		// Version is a resource version
		"version": {
			Type:        schema.TypeString,
			Description: "Version is a resource version",
			Optional:    true,
			Computed:    true,
		},
		// Metadata is resource metadata
		"metadata": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "Metadata is resource metadata",

			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Namespace is object namespace. The field should be called "namespace"
					// when it returns in Teleport 2.4.
					"namespace": {
						Type:        schema.TypeString,
						Description: "Namespace is object namespace. The field should be called \"namespace\"  when it returns in Teleport 2.4.",
						Optional:    true,
						Computed:    true,
					},
					// Description is object description
					"description": {
						Type:        schema.TypeString,
						Description: "Description is object description",
						Optional:    true,
					},
					// Labels is a set of labels
					"labels": {

						Optional:    true,
						Type:        schema.TypeMap,
						Description: "Labels is a set of labels",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},
					// Expires is a global expiry time header can be set on any resource in the
					// system.
					"expires": {
						Type:         schema.TypeString,
						Description:  "Expires is a global expiry time header can be set on any resource in the  system.",
						ValidateFunc: validation.IsRFC3339Time,
						StateFunc:    TruncateMs,
						Optional:     true,
					},
				},
			},
		},
		// Spec is an AuthPreference specification
		"spec": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "AuthPreferenceSpecV2 is the actual data we care about for AuthPreference.",

			Required: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Type is the type of authentication.
					"type": {
						Type:        schema.TypeString,
						Description: "Type is the type of authentication.",
						Optional:    true,
						Computed:    true,
					},
					// SecondFactor is the type of second factor.
					"second_factor": {
						Type:        schema.TypeString,
						Description: "SecondFactor is the type of second factor.",
						Optional:    true,
						Computed:    true,
					},
					// ConnectorName is the name of the OIDC or SAML connector. If this value is
					// not set the first connector in the backend will be used.
					"connector_name": {
						Type:        schema.TypeString,
						Description: "ConnectorName is the name of the OIDC or SAML connector. If this value is  not set the first connector in the backend will be used.",
						Optional:    true,
					},
					// U2F are the settings for the U2F device.
					"u2f": {
						Type:        schema.TypeList,
						MaxItems:    1,
						Description: "U2F defines settings for U2F device.",

						Optional: true,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// AppID returns the application ID for universal second factor.
								"app_id": {
									Type:        schema.TypeString,
									Description: "AppID returns the application ID for universal second factor.",
									Optional:    true,
								},
								// Facets returns the facets for universal second factor.
								"facets": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "Facets returns the facets for universal second factor.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
								// DeviceAttestationCAs contains the trusted attestation CAs for U2F
								// devices.
								"device_attestation_cas": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "DeviceAttestationCAs contains the trusted attestation CAs for U2F  devices.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
							},
						},
					},
					// RequireSessionMFA causes all sessions in this cluster to require MFA
					// checks.
					"require_session_mfa": {
						Type:        schema.TypeBool,
						Description: "RequireSessionMFA causes all sessions in this cluster to require MFA  checks.",
						Optional:    true,
					},
					// DisconnectExpiredCert provides disconnect expired certificate setting -
					// if true, connections with expired client certificates will get disconnected
					"disconnect_expired_cert": SchemaBoolOption(),
					// AllowLocalAuth is true if local authentication is enabled.
					"allow_local_auth": SchemaBoolOption(),

					"message_of_the_day": {
						Type:        schema.TypeString,
						Description: "",
						Optional:    true,
					},
					// LockingMode is the cluster-wide locking mode default.
					"locking_mode": {
						Type:        schema.TypeString,
						Description: "LockingMode is the cluster-wide locking mode default.",
						Optional:    true,
						Computed:    true,
					},
					// Webauthn are the settings for server-side Web Authentication support.
					"webauthn": {
						Type:        schema.TypeList,
						MaxItems:    1,
						Description: "Webauthn defines user-visible settings for server-side Web Authentication  support.",

						Optional: true,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// RPID is the ID of the Relying Party.
								// It should be set to the domain name of the Teleport installation.
								// IMPORTANT: RPID must never change in the lifetime of the cluster, because
								// it's recorded in the registration data on the WebAuthn device. If the
								// RPID changes, all existing WebAuthn key registrations will become invalid
								// and all users who use WebAuthn as the second factor will need to
								// re-register.
								"rp_id": {
									Type:        schema.TypeString,
									Description: "RPID is the ID of the Relying Party.  It should be set to the domain name of the Teleport installation.   IMPORTANT: RPID must never change in the lifetime of the cluster, because  it's recorded in the registration data on the WebAuthn device. If the  RPID changes, all existing WebAuthn key registrations will become invalid  and all users who use WebAuthn as the second factor will need to  re-register.",
									Optional:    true,
								},
								// Allow list of device attestation CAs in PEM format.
								// If present, only devices whose attestation certificates match the
								// certificates specified here may be registered (existing registrations are
								// unchanged).
								// If supplied in conjunction with AttestationDeniedCAs, then both
								// conditions need to be true for registration to be allowed (the device
								// MUST match an allowed CA and MUST NOT match a denied CA).
								// By default all devices are allowed.
								"attestation_allowed_cas": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "Allow list of device attestation CAs in PEM format.  If present, only devices whose attestation certificates match the  certificates specified here may be registered (existing registrations are  unchanged).  If supplied in conjunction with AttestationDeniedCAs, then both  conditions need to be true for registration to be allowed (the device  MUST match an allowed CA and MUST NOT match a denied CA).  By default all devices are allowed.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
								// Deny list of device attestation CAs in PEM format.
								// If present, only devices whose attestation certificates don't match the
								// certificates specified here may be registered (existing registrations are
								// unchanged).
								// If supplied in conjunction with AttestationAllowedCAs, then both
								// conditions need to be true for registration to be allowed (the device
								// MUST match an allowed CA and MUST NOT match a denied CA).
								// By default no devices are denied.
								"attestation_denied_cas": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "Deny list of device attestation CAs in PEM format.  If present, only devices whose attestation certificates don't match the  certificates specified here may be registered (existing registrations are  unchanged).  If supplied in conjunction with AttestationAllowedCAs, then both  conditions need to be true for registration to be allowed (the device  MUST match an allowed CA and MUST NOT match a denied CA).  By default no devices are denied.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
								// Disables Webauthn, regardless of other cluster settings.
								// Allows fallback to pure U2F in clusters with second_factor:on or
								// second_factor:optional.
								// Must not be set for clusters with second_factor:webauthn.
								// Temporary safety switch for Webauthn, to be removed in future versions of
								// Teleport.
								// DELETE IN 9.x, fallback not possible without U2F (codingllama).
								"disabled": {
									Type:        schema.TypeBool,
									Description: "Disables Webauthn, regardless of other cluster settings.  Allows fallback to pure U2F in clusters with second_factor:on or  second_factor:optional.  Must not be set for clusters with second_factor:webauthn.  Temporary safety switch for Webauthn, to be removed in future versions of  Teleport.  DELETE IN 9.x, fallback not possible without U2F (codingllama).",
									Optional:    true,
								},
							},
						},
					},
				},
			},
		},
	}
}

// GenSchemaMetaAuthPreferenceV2 returns schema for AuthPreferenceV2
//
// AuthPreferenceV2 implements the AuthPreference interface.
func GenSchemaMetaAuthPreferenceV2() map[string]*accessors.SchemaMeta {
	return map[string]*accessors.SchemaMeta{
		// Kind is a resource kind
		"kind": {
			Name:       "Kind",
			IsTime:     false,
			IsDuration: false,
		},
		// SubKind is an optional resource sub kind, used in some resources
		"sub_kind": {
			Name:       "SubKind",
			IsTime:     false,
			IsDuration: false,
		},
		// Version is a resource version
		"version": {
			Name:       "Version",
			IsTime:     false,
			IsDuration: false,
		},
		// Metadata is resource metadata
		"metadata": {
			Name:       "Metadata",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Namespace is object namespace. The field should be called "namespace"
				// when it returns in Teleport 2.4.
				"namespace": {
					Name:       "Namespace",
					IsTime:     false,
					IsDuration: false,
				},
				// Description is object description
				"description": {
					Name:       "Description",
					IsTime:     false,
					IsDuration: false,
				},
				// Labels is a set of labels
				"labels": {
					Name:       "Labels",
					IsTime:     false,
					IsDuration: false,
				},
				// Expires is a global expiry time header can be set on any resource in the
				// system.
				"expires": {
					Name:       "Expires",
					IsTime:     true,
					IsDuration: false,
				},
			},
		},
		// Spec is an AuthPreference specification
		"spec": {
			Name:       "Spec",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Type is the type of authentication.
				"type": {
					Name:       "Type",
					IsTime:     false,
					IsDuration: false,
				},
				// SecondFactor is the type of second factor.
				"second_factor": {
					Name:       "SecondFactor",
					IsTime:     false,
					IsDuration: false,
				},
				// ConnectorName is the name of the OIDC or SAML connector. If this value is
				// not set the first connector in the backend will be used.
				"connector_name": {
					Name:       "ConnectorName",
					IsTime:     false,
					IsDuration: false,
				},
				// U2F are the settings for the U2F device.
				"u2f": {
					Name:       "U2F",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// AppID returns the application ID for universal second factor.
						"app_id": {
							Name:       "AppID",
							IsTime:     false,
							IsDuration: false,
						},
						// Facets returns the facets for universal second factor.
						"facets": {
							Name:       "Facets",
							IsTime:     false,
							IsDuration: false,
						},
						// DeviceAttestationCAs contains the trusted attestation CAs for U2F
						// devices.
						"device_attestation_cas": {
							Name:       "DeviceAttestationCAs",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
				// RequireSessionMFA causes all sessions in this cluster to require MFA
				// checks.
				"require_session_mfa": {
					Name:       "RequireSessionMFA",
					IsTime:     false,
					IsDuration: false,
				},
				// DisconnectExpiredCert provides disconnect expired certificate setting -
				// if true, connections with expired client certificates will get disconnected
				"disconnect_expired_cert": {
					Name:          "DisconnectExpiredCert",
					IsTime:        false,
					IsDuration:    false,
					FromTerraform: FromTerraformBoolOption,
					ToTerraform:   ToTerraformBoolOption,
				},
				// AllowLocalAuth is true if local authentication is enabled.
				"allow_local_auth": {
					Name:          "AllowLocalAuth",
					IsTime:        false,
					IsDuration:    false,
					FromTerraform: FromTerraformBoolOption,
					ToTerraform:   ToTerraformBoolOption,
				},

				"message_of_the_day": {
					Name:       "MessageOfTheDay",
					IsTime:     false,
					IsDuration: false,
				},
				// LockingMode is the cluster-wide locking mode default.
				"locking_mode": {
					Name:       "LockingMode",
					IsTime:     false,
					IsDuration: false,
				},
				// Webauthn are the settings for server-side Web Authentication support.
				"webauthn": {
					Name:       "Webauthn",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// RPID is the ID of the Relying Party.
						// It should be set to the domain name of the Teleport installation.
						// IMPORTANT: RPID must never change in the lifetime of the cluster, because
						// it's recorded in the registration data on the WebAuthn device. If the
						// RPID changes, all existing WebAuthn key registrations will become invalid
						// and all users who use WebAuthn as the second factor will need to
						// re-register.
						"rp_id": {
							Name:       "RPID",
							IsTime:     false,
							IsDuration: false,
						},
						// Allow list of device attestation CAs in PEM format.
						// If present, only devices whose attestation certificates match the
						// certificates specified here may be registered (existing registrations are
						// unchanged).
						// If supplied in conjunction with AttestationDeniedCAs, then both
						// conditions need to be true for registration to be allowed (the device
						// MUST match an allowed CA and MUST NOT match a denied CA).
						// By default all devices are allowed.
						"attestation_allowed_cas": {
							Name:       "AttestationAllowedCAs",
							IsTime:     false,
							IsDuration: false,
						},
						// Deny list of device attestation CAs in PEM format.
						// If present, only devices whose attestation certificates don't match the
						// certificates specified here may be registered (existing registrations are
						// unchanged).
						// If supplied in conjunction with AttestationAllowedCAs, then both
						// conditions need to be true for registration to be allowed (the device
						// MUST match an allowed CA and MUST NOT match a denied CA).
						// By default no devices are denied.
						"attestation_denied_cas": {
							Name:       "AttestationDeniedCAs",
							IsTime:     false,
							IsDuration: false,
						},
						// Disables Webauthn, regardless of other cluster settings.
						// Allows fallback to pure U2F in clusters with second_factor:on or
						// second_factor:optional.
						// Must not be set for clusters with second_factor:webauthn.
						// Temporary safety switch for Webauthn, to be removed in future versions of
						// Teleport.
						// DELETE IN 9.x, fallback not possible without U2F (codingllama).
						"disabled": {
							Name:       "Disabled",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
			},
		},
	}
}

// SchemaRoleV4 returns schema for RoleV4
//
// RoleV4 represents role resource specification
func GenSchemaRoleV4() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		// Kind is a resource kind
		"kind": {
			Type:        schema.TypeString,
			Description: "Kind is a resource kind",
			Optional:    true,
			Computed:    true,
		},
		// SubKind is an optional resource sub kind, used in some resources
		"sub_kind": {
			Type:        schema.TypeString,
			Description: "SubKind is an optional resource sub kind, used in some resources",
			Optional:    true,
		},
		// Version is version
		"version": {
			Type:        schema.TypeString,
			Description: "Version is version",
			Optional:    true,
			Computed:    true,
		},
		// Metadata is resource metadata
		"metadata": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "Metadata is resource metadata",

			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Name is an object name
					"name": {
						Type:        schema.TypeString,
						Description: "Name is an object name",
						Required:    true,
						ForceNew:    true,
					},
					// Namespace is object namespace. The field should be called "namespace"
					// when it returns in Teleport 2.4.
					"namespace": {
						Type:        schema.TypeString,
						Description: "Namespace is object namespace. The field should be called \"namespace\"  when it returns in Teleport 2.4.",
						Optional:    true,
						Computed:    true,
					},
					// Description is object description
					"description": {
						Type:        schema.TypeString,
						Description: "Description is object description",
						Optional:    true,
					},
					// Labels is a set of labels
					"labels": {

						Optional:    true,
						Type:        schema.TypeMap,
						Description: "Labels is a set of labels",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},
					// Expires is a global expiry time header can be set on any resource in the
					// system.
					"expires": {
						Type:         schema.TypeString,
						Description:  "Expires is a global expiry time header can be set on any resource in the  system.",
						ValidateFunc: validation.IsRFC3339Time,
						StateFunc:    TruncateMs,
						Optional:     true,
					},
				},
			},
		},
		// Spec is a role specification
		"spec": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "RoleSpecV4 is role specification for RoleV4.",

			Required: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Options is for OpenSSH options like agent forwarding.
					"options": {
						Type:        schema.TypeList,
						MaxItems:    1,
						Description: "RoleOptions is a set of role options",

						Optional: true,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// ForwardAgent is SSH agent forwarding.
								"forward_agent": {
									Type:        schema.TypeBool,
									Description: "ForwardAgent is SSH agent forwarding.",
									Optional:    true,
								},
								// MaxSessionTTL defines how long a SSH session can last for.
								"max_session_ttl": {
									Type:             schema.TypeString,
									Description:      "MaxSessionTTL defines how long a SSH session can last for.",
									DiffSuppressFunc: SuppressDurationChange,
									Optional:         true,
									Computed:         true,
								},
								// PortForwarding defines if the certificate will have
								// "permit-port-forwarding"
								// in the certificate. PortForwarding is "yes" if not set,
								// that's why this is a pointer
								"port_forwarding": SchemaBoolOption(),
								// CertificateFormat defines the format of the user certificate to allow
								// compatibility with older versions of OpenSSH.
								"cert_format": {
									Type:        schema.TypeString,
									Description: "CertificateFormat defines the format of the user certificate to allow  compatibility with older versions of OpenSSH.",
									Optional:    true,
									Computed:    true,
								},
								// ClientIdleTimeout sets disconnect clients on idle timeout behavior,
								// if set to 0 means do not disconnect, otherwise is set to the idle
								// duration.
								"client_idle_timeout": {
									Type:             schema.TypeString,
									Description:      "ClientIdleTimeout sets disconnect clients on idle timeout behavior,  if set to 0 means do not disconnect, otherwise is set to the idle  duration.",
									DiffSuppressFunc: SuppressDurationChange,
									Optional:         true,
								},
								// DisconnectExpiredCert sets disconnect clients on expired certificates.
								"disconnect_expired_cert": {
									Type:        schema.TypeBool,
									Description: "DisconnectExpiredCert sets disconnect clients on expired certificates.",
									Optional:    true,
								},
								// BPF defines what events to record for the BPF-based session recorder.
								"enhanced_recording": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "BPF defines what events to record for the BPF-based session recorder.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
								// PermitX11Forwarding authorizes use of X11 forwarding.
								"permit_x11_forwarding": {
									Type:        schema.TypeBool,
									Description: "PermitX11Forwarding authorizes use of X11 forwarding.",
									Optional:    true,
								},
								// MaxConnections defines the maximum number of
								// concurrent connections a user may hold.
								"max_connections": {
									Type:        schema.TypeInt,
									Description: "MaxConnections defines the maximum number of  concurrent connections a user may hold.",
									Optional:    true,
								},
								// MaxSessions defines the maximum number of
								// concurrent sessions per connection.
								"max_sessions": {
									Type:        schema.TypeInt,
									Description: "MaxSessions defines the maximum number of  concurrent sessions per connection.",
									Optional:    true,
								},
								// RequestAccess defines the access request stategy (optional|note|always)
								// where optional is the default.
								"request_access": {
									Type:        schema.TypeString,
									Description: "RequestAccess defines the access request stategy (optional|note|always)  where optional is the default.",
									Optional:    true,
								},
								// RequestPrompt is an optional message which tells users what they aught to
								"request_prompt": {
									Type:        schema.TypeString,
									Description: "RequestPrompt is an optional message which tells users what they aught to",
									Optional:    true,
								},
								// RequireSessionMFA specifies whether a user is required to do an MFA
								// check for every session.
								"require_session_mfa": {
									Type:        schema.TypeBool,
									Description: "RequireSessionMFA specifies whether a user is required to do an MFA  check for every session.",
									Optional:    true,
								},
								// Lock specifies the locking mode (strict|best_effort) to be applied with
								// the role.
								"lock": {
									Type:        schema.TypeString,
									Description: "Lock specifies the locking mode (strict|best_effort) to be applied with  the role.",
									Optional:    true,
								},
							},
						},
					},
					// Allow is the set of conditions evaluated to grant access.
					"allow": {
						Type:        schema.TypeList,
						MaxItems:    1,
						Description: "RoleConditions is a set of conditions that must all match to be allowed or  denied access.",

						Optional: true,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// Logins is a list of *nix system logins.
								"logins": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "Logins is a list of *nix system logins.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
								// NodeLabels is a map of node labels (used to dynamically grant access to
								// nodes).
								"node_labels": SchemaLabels(),
								// Rules is a list of rules and their access levels. Rules are a high level
								// construct used for access control.
								"rules": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "Rules is a list of rules and their access levels. Rules are a high level  construct used for access control.",
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											// Resources is a list of resources
											"resources": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Resources is a list of resources",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
											// Verbs is a list of verbs
											"verbs": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Verbs is a list of verbs",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
											// Where specifies optional advanced matcher
											"where": {
												Type:        schema.TypeString,
												Description: "Where specifies optional advanced matcher",
												Optional:    true,
											},
											// Actions specifies optional actions taken when this rule matches
											"actions": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Actions specifies optional actions taken when this rule matches",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
										},
									},
								},
								// KubeGroups is a list of kubernetes groups
								"kubernetes_groups": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "KubeGroups is a list of kubernetes groups",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},

								"request": {
									Type:        schema.TypeList,
									MaxItems:    1,
									Description: "AccessRequestConditions is a matcher for allow/deny restrictions on  access-requests.",

									Optional: true,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											// Roles is the name of roles which will match the request rule.
											"roles": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Roles is the name of roles which will match the request rule.",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
											// ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
											"claims_to_roles": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.",
												Elem: &schema.Resource{
													Schema: map[string]*schema.Schema{
														// Claim is a claim name.
														"claim": {
															Type:        schema.TypeString,
															Description: "Claim is a claim name.",
															Optional:    true,
														},
														// Value is a claim value to match.
														"value": {
															Type:        schema.TypeString,
															Description: "Value is a claim value to match.",
															Optional:    true,
														},
														// Roles is a list of static teleport roles to match.
														"roles": {

															Optional:    true,
															Type:        schema.TypeList,
															Description: "Roles is a list of static teleport roles to match.",
															Elem: &schema.Schema{
																Type: schema.TypeString,
															},
														},
													},
												},
											},
											// Annotations is a collection of annotations to be programmatically
											// appended to pending access requests at the time of their creation.
											// These annotations serve as a mechanism to propagate extra information
											// to plugins.  Since these annotations support variable interpolation
											// syntax, they also offer a mechanism for forwarding claims from an
											// external identity provider, to a plugin via `{{external.trait_name}}`
											// style substitutions.
											"annotations": SchemaTraits(),
											// Thresholds is a list of thresholds, one of which must be met in order for reviews
											// to trigger a state-transition.  If no thresholds are provided, a default threshold
											// of 1 for approval and denial is used.
											"thresholds": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Thresholds is a list of thresholds, one of which must be met in order for reviews  to trigger a state-transition.  If no thresholds are provided, a default threshold  of 1 for approval and denial is used.",
												Elem: &schema.Resource{
													Schema: map[string]*schema.Schema{
														// Name is the optional human-readable name of the threshold.
														"name": {
															Type:        schema.TypeString,
															Description: "Name is the optional human-readable name of the threshold.",
															Optional:    true,
														},
														// Filter is an optional predicate used to determine which reviews
														// count toward this threshold.
														"filter": {
															Type:        schema.TypeString,
															Description: "Filter is an optional predicate used to determine which reviews  count toward this threshold.",
															Optional:    true,
														},
														// Approve is the number of matching approvals needed for state-transition.
														"approve": {
															Type:        schema.TypeInt,
															Description: "Approve is the number of matching approvals needed for state-transition.",
															Optional:    true,
														},
														// Deny is the number of denials needed for state-transition.
														"deny": {
															Type:        schema.TypeInt,
															Description: "Deny is the number of denials needed for state-transition.",
															Optional:    true,
														},
													},
												},
											},
											// SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but
											// that is not a requirement.
											"suggested_reviewers": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but  that is not a requirement.",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
										},
									},
								},
								// KubeUsers is an optional kubernetes users to impersonate
								"kubernetes_users": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "KubeUsers is an optional kubernetes users to impersonate",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
								// AppLabels is a map of labels used as part of the RBAC system.
								"app_labels": SchemaLabels(),
								// ClusterLabels is a map of node labels (used to dynamically grant access to
								// clusters).
								"cluster_labels": SchemaLabels(),
								// KubernetesLabels is a map of kubernetes cluster labels used for RBAC.
								"kubernetes_labels": SchemaLabels(),
								// DatabaseLabels are used in RBAC system to allow/deny access to databases.
								"db_labels": SchemaLabels(),
								// DatabaseNames is a list of database names this role is allowed to connect to.
								"db_names": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "DatabaseNames is a list of database names this role is allowed to connect to.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
								// DatabaseUsers is a list of databaes users this role is allowed to connect as.
								"db_users": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "DatabaseUsers is a list of databaes users this role is allowed to connect as.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
								// Impersonate specifies what users and roles this role is allowed to impersonate
								// by issuing certificates or other possible means.
								"impersonate": {
									Type:        schema.TypeList,
									MaxItems:    1,
									Description: "ImpersonateConditions specifies whether users are allowed  to issue certificates for other users or groups.",

									Optional: true,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											// Users is a list of resources this role is allowed to impersonate,
											// could be an empty list or a Wildcard pattern
											"users": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Users is a list of resources this role is allowed to impersonate,  could be an empty list or a Wildcard pattern",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
											// Roles is a list of resources this role is allowed to impersonate
											"roles": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Roles is a list of resources this role is allowed to impersonate",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
											// Where specifies optional advanced matcher
											"where": {
												Type:        schema.TypeString,
												Description: "Where specifies optional advanced matcher",
												Optional:    true,
											},
										},
									},
								},
								// ReviewRequests defines conditions for submitting access reviews.
								"review_requests": {
									Type:        schema.TypeList,
									MaxItems:    1,
									Description: "AccessReviewConditions is a matcher for allow/deny restrictions on  access reviews.",

									Optional: true,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											// Roles is the name of roles which may be reviewed.
											"roles": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Roles is the name of roles which may be reviewed.",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
											// ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
											"claims_to_roles": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.",
												Elem: &schema.Resource{
													Schema: map[string]*schema.Schema{
														// Claim is a claim name.
														"claim": {
															Type:        schema.TypeString,
															Description: "Claim is a claim name.",
															Optional:    true,
														},
														// Value is a claim value to match.
														"value": {
															Type:        schema.TypeString,
															Description: "Value is a claim value to match.",
															Optional:    true,
														},
														// Roles is a list of static teleport roles to match.
														"roles": {

															Optional:    true,
															Type:        schema.TypeList,
															Description: "Roles is a list of static teleport roles to match.",
															Elem: &schema.Schema{
																Type: schema.TypeString,
															},
														},
													},
												},
											},
											// Where is an optional predicate which further limits which requests are
											// reviewable.
											"where": {
												Type:        schema.TypeString,
												Description: "Where is an optional predicate which further limits which requests are  reviewable.",
												Optional:    true,
											},
										},
									},
								},
								// AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.
								"aws_role_arns": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
							},
						},
					},
					// Deny is the set of conditions evaluated to deny access. Deny takes priority
					// over allow.
					"deny": {
						Type:        schema.TypeList,
						MaxItems:    1,
						Description: "RoleConditions is a set of conditions that must all match to be allowed or  denied access.",

						Optional: true,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// Logins is a list of *nix system logins.
								"logins": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "Logins is a list of *nix system logins.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
								// NodeLabels is a map of node labels (used to dynamically grant access to
								// nodes).
								"node_labels": SchemaLabels(),
								// Rules is a list of rules and their access levels. Rules are a high level
								// construct used for access control.
								"rules": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "Rules is a list of rules and their access levels. Rules are a high level  construct used for access control.",
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											// Resources is a list of resources
											"resources": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Resources is a list of resources",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
											// Verbs is a list of verbs
											"verbs": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Verbs is a list of verbs",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
											// Where specifies optional advanced matcher
											"where": {
												Type:        schema.TypeString,
												Description: "Where specifies optional advanced matcher",
												Optional:    true,
											},
											// Actions specifies optional actions taken when this rule matches
											"actions": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Actions specifies optional actions taken when this rule matches",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
										},
									},
								},
								// KubeGroups is a list of kubernetes groups
								"kubernetes_groups": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "KubeGroups is a list of kubernetes groups",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},

								"request": {
									Type:        schema.TypeList,
									MaxItems:    1,
									Description: "AccessRequestConditions is a matcher for allow/deny restrictions on  access-requests.",

									Optional: true,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											// Roles is the name of roles which will match the request rule.
											"roles": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Roles is the name of roles which will match the request rule.",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
											// ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
											"claims_to_roles": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.",
												Elem: &schema.Resource{
													Schema: map[string]*schema.Schema{
														// Claim is a claim name.
														"claim": {
															Type:        schema.TypeString,
															Description: "Claim is a claim name.",
															Optional:    true,
														},
														// Value is a claim value to match.
														"value": {
															Type:        schema.TypeString,
															Description: "Value is a claim value to match.",
															Optional:    true,
														},
														// Roles is a list of static teleport roles to match.
														"roles": {

															Optional:    true,
															Type:        schema.TypeList,
															Description: "Roles is a list of static teleport roles to match.",
															Elem: &schema.Schema{
																Type: schema.TypeString,
															},
														},
													},
												},
											},
											// Annotations is a collection of annotations to be programmatically
											// appended to pending access requests at the time of their creation.
											// These annotations serve as a mechanism to propagate extra information
											// to plugins.  Since these annotations support variable interpolation
											// syntax, they also offer a mechanism for forwarding claims from an
											// external identity provider, to a plugin via `{{external.trait_name}}`
											// style substitutions.
											"annotations": SchemaTraits(),
											// Thresholds is a list of thresholds, one of which must be met in order for reviews
											// to trigger a state-transition.  If no thresholds are provided, a default threshold
											// of 1 for approval and denial is used.
											"thresholds": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Thresholds is a list of thresholds, one of which must be met in order for reviews  to trigger a state-transition.  If no thresholds are provided, a default threshold  of 1 for approval and denial is used.",
												Elem: &schema.Resource{
													Schema: map[string]*schema.Schema{
														// Name is the optional human-readable name of the threshold.
														"name": {
															Type:        schema.TypeString,
															Description: "Name is the optional human-readable name of the threshold.",
															Optional:    true,
														},
														// Filter is an optional predicate used to determine which reviews
														// count toward this threshold.
														"filter": {
															Type:        schema.TypeString,
															Description: "Filter is an optional predicate used to determine which reviews  count toward this threshold.",
															Optional:    true,
														},
														// Approve is the number of matching approvals needed for state-transition.
														"approve": {
															Type:        schema.TypeInt,
															Description: "Approve is the number of matching approvals needed for state-transition.",
															Optional:    true,
														},
														// Deny is the number of denials needed for state-transition.
														"deny": {
															Type:        schema.TypeInt,
															Description: "Deny is the number of denials needed for state-transition.",
															Optional:    true,
														},
													},
												},
											},
											// SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but
											// that is not a requirement.
											"suggested_reviewers": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but  that is not a requirement.",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
										},
									},
								},
								// KubeUsers is an optional kubernetes users to impersonate
								"kubernetes_users": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "KubeUsers is an optional kubernetes users to impersonate",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
								// AppLabels is a map of labels used as part of the RBAC system.
								"app_labels": SchemaLabels(),
								// ClusterLabels is a map of node labels (used to dynamically grant access to
								// clusters).
								"cluster_labels": SchemaLabels(),
								// KubernetesLabels is a map of kubernetes cluster labels used for RBAC.
								"kubernetes_labels": SchemaLabels(),
								// DatabaseLabels are used in RBAC system to allow/deny access to databases.
								"db_labels": SchemaLabels(),
								// DatabaseNames is a list of database names this role is allowed to connect to.
								"db_names": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "DatabaseNames is a list of database names this role is allowed to connect to.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
								// DatabaseUsers is a list of databaes users this role is allowed to connect as.
								"db_users": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "DatabaseUsers is a list of databaes users this role is allowed to connect as.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
								// Impersonate specifies what users and roles this role is allowed to impersonate
								// by issuing certificates or other possible means.
								"impersonate": {
									Type:        schema.TypeList,
									MaxItems:    1,
									Description: "ImpersonateConditions specifies whether users are allowed  to issue certificates for other users or groups.",

									Optional: true,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											// Users is a list of resources this role is allowed to impersonate,
											// could be an empty list or a Wildcard pattern
											"users": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Users is a list of resources this role is allowed to impersonate,  could be an empty list or a Wildcard pattern",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
											// Roles is a list of resources this role is allowed to impersonate
											"roles": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Roles is a list of resources this role is allowed to impersonate",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
											// Where specifies optional advanced matcher
											"where": {
												Type:        schema.TypeString,
												Description: "Where specifies optional advanced matcher",
												Optional:    true,
											},
										},
									},
								},
								// ReviewRequests defines conditions for submitting access reviews.
								"review_requests": {
									Type:        schema.TypeList,
									MaxItems:    1,
									Description: "AccessReviewConditions is a matcher for allow/deny restrictions on  access reviews.",

									Optional: true,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											// Roles is the name of roles which may be reviewed.
											"roles": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "Roles is the name of roles which may be reviewed.",
												Elem: &schema.Schema{
													Type: schema.TypeString,
												},
											},
											// ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
											"claims_to_roles": {

												Optional:    true,
												Type:        schema.TypeList,
												Description: "ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.",
												Elem: &schema.Resource{
													Schema: map[string]*schema.Schema{
														// Claim is a claim name.
														"claim": {
															Type:        schema.TypeString,
															Description: "Claim is a claim name.",
															Optional:    true,
														},
														// Value is a claim value to match.
														"value": {
															Type:        schema.TypeString,
															Description: "Value is a claim value to match.",
															Optional:    true,
														},
														// Roles is a list of static teleport roles to match.
														"roles": {

															Optional:    true,
															Type:        schema.TypeList,
															Description: "Roles is a list of static teleport roles to match.",
															Elem: &schema.Schema{
																Type: schema.TypeString,
															},
														},
													},
												},
											},
											// Where is an optional predicate which further limits which requests are
											// reviewable.
											"where": {
												Type:        schema.TypeString,
												Description: "Where is an optional predicate which further limits which requests are  reviewable.",
												Optional:    true,
											},
										},
									},
								},
								// AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.
								"aws_role_arns": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// GenSchemaMetaRoleV4 returns schema for RoleV4
//
// RoleV4 represents role resource specification
func GenSchemaMetaRoleV4() map[string]*accessors.SchemaMeta {
	return map[string]*accessors.SchemaMeta{
		// Kind is a resource kind
		"kind": {
			Name:       "Kind",
			IsTime:     false,
			IsDuration: false,
		},
		// SubKind is an optional resource sub kind, used in some resources
		"sub_kind": {
			Name:       "SubKind",
			IsTime:     false,
			IsDuration: false,
		},
		// Version is version
		"version": {
			Name:       "Version",
			IsTime:     false,
			IsDuration: false,
		},
		// Metadata is resource metadata
		"metadata": {
			Name:       "Metadata",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Name is an object name
				"name": {
					Name:       "Name",
					IsTime:     false,
					IsDuration: false,
				},
				// Namespace is object namespace. The field should be called "namespace"
				// when it returns in Teleport 2.4.
				"namespace": {
					Name:       "Namespace",
					IsTime:     false,
					IsDuration: false,
				},
				// Description is object description
				"description": {
					Name:       "Description",
					IsTime:     false,
					IsDuration: false,
				},
				// Labels is a set of labels
				"labels": {
					Name:       "Labels",
					IsTime:     false,
					IsDuration: false,
				},
				// Expires is a global expiry time header can be set on any resource in the
				// system.
				"expires": {
					Name:       "Expires",
					IsTime:     true,
					IsDuration: false,
				},
			},
		},
		// Spec is a role specification
		"spec": {
			Name:       "Spec",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Options is for OpenSSH options like agent forwarding.
				"options": {
					Name:       "Options",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// ForwardAgent is SSH agent forwarding.
						"forward_agent": {
							Name:       "ForwardAgent",
							IsTime:     false,
							IsDuration: false,
						},
						// MaxSessionTTL defines how long a SSH session can last for.
						"max_session_ttl": {
							Name:       "MaxSessionTTL",
							IsTime:     false,
							IsDuration: true,
						},
						// PortForwarding defines if the certificate will have
						// "permit-port-forwarding"
						// in the certificate. PortForwarding is "yes" if not set,
						// that's why this is a pointer
						"port_forwarding": {
							Name:          "PortForwarding",
							IsTime:        false,
							IsDuration:    false,
							FromTerraform: FromTerraformBoolOption,
							ToTerraform:   ToTerraformBoolOption,
						},
						// CertificateFormat defines the format of the user certificate to allow
						// compatibility with older versions of OpenSSH.
						"cert_format": {
							Name:       "CertificateFormat",
							IsTime:     false,
							IsDuration: false,
						},
						// ClientIdleTimeout sets disconnect clients on idle timeout behavior,
						// if set to 0 means do not disconnect, otherwise is set to the idle
						// duration.
						"client_idle_timeout": {
							Name:       "ClientIdleTimeout",
							IsTime:     false,
							IsDuration: true,
						},
						// DisconnectExpiredCert sets disconnect clients on expired certificates.
						"disconnect_expired_cert": {
							Name:       "DisconnectExpiredCert",
							IsTime:     false,
							IsDuration: false,
						},
						// BPF defines what events to record for the BPF-based session recorder.
						"enhanced_recording": {
							Name:       "BPF",
							IsTime:     false,
							IsDuration: false,
						},
						// PermitX11Forwarding authorizes use of X11 forwarding.
						"permit_x11_forwarding": {
							Name:       "PermitX11Forwarding",
							IsTime:     false,
							IsDuration: false,
						},
						// MaxConnections defines the maximum number of
						// concurrent connections a user may hold.
						"max_connections": {
							Name:       "MaxConnections",
							IsTime:     false,
							IsDuration: false,
						},
						// MaxSessions defines the maximum number of
						// concurrent sessions per connection.
						"max_sessions": {
							Name:       "MaxSessions",
							IsTime:     false,
							IsDuration: false,
						},
						// RequestAccess defines the access request stategy (optional|note|always)
						// where optional is the default.
						"request_access": {
							Name:       "RequestAccess",
							IsTime:     false,
							IsDuration: false,
						},
						// RequestPrompt is an optional message which tells users what they aught to
						"request_prompt": {
							Name:       "RequestPrompt",
							IsTime:     false,
							IsDuration: false,
						},
						// RequireSessionMFA specifies whether a user is required to do an MFA
						// check for every session.
						"require_session_mfa": {
							Name:       "RequireSessionMFA",
							IsTime:     false,
							IsDuration: false,
						},
						// Lock specifies the locking mode (strict|best_effort) to be applied with
						// the role.
						"lock": {
							Name:       "Lock",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
				// Allow is the set of conditions evaluated to grant access.
				"allow": {
					Name:       "Allow",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// Logins is a list of *nix system logins.
						"logins": {
							Name:       "Logins",
							IsTime:     false,
							IsDuration: false,
						},
						// NodeLabels is a map of node labels (used to dynamically grant access to
						// nodes).
						"node_labels": {
							Name:          "NodeLabels",
							IsTime:        false,
							IsDuration:    false,
							FromTerraform: FromTerraformLabels,
							ToTerraform:   ToTerraformLabels,
						},
						// Rules is a list of rules and their access levels. Rules are a high level
						// construct used for access control.
						"rules": {
							Name:       "Rules",
							IsTime:     false,
							IsDuration: false,
							Nested: map[string]*accessors.SchemaMeta{
								// Resources is a list of resources
								"resources": {
									Name:       "Resources",
									IsTime:     false,
									IsDuration: false,
								},
								// Verbs is a list of verbs
								"verbs": {
									Name:       "Verbs",
									IsTime:     false,
									IsDuration: false,
								},
								// Where specifies optional advanced matcher
								"where": {
									Name:       "Where",
									IsTime:     false,
									IsDuration: false,
								},
								// Actions specifies optional actions taken when this rule matches
								"actions": {
									Name:       "Actions",
									IsTime:     false,
									IsDuration: false,
								},
							},
						},
						// KubeGroups is a list of kubernetes groups
						"kubernetes_groups": {
							Name:       "KubeGroups",
							IsTime:     false,
							IsDuration: false,
						},

						"request": {
							Name:       "Request",
							IsTime:     false,
							IsDuration: false,
							Nested: map[string]*accessors.SchemaMeta{
								// Roles is the name of roles which will match the request rule.
								"roles": {
									Name:       "Roles",
									IsTime:     false,
									IsDuration: false,
								},
								// ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
								"claims_to_roles": {
									Name:       "ClaimsToRoles",
									IsTime:     false,
									IsDuration: false,
									Nested: map[string]*accessors.SchemaMeta{
										// Claim is a claim name.
										"claim": {
											Name:       "Claim",
											IsTime:     false,
											IsDuration: false,
										},
										// Value is a claim value to match.
										"value": {
											Name:       "Value",
											IsTime:     false,
											IsDuration: false,
										},
										// Roles is a list of static teleport roles to match.
										"roles": {
											Name:       "Roles",
											IsTime:     false,
											IsDuration: false,
										},
									},
								},
								// Annotations is a collection of annotations to be programmatically
								// appended to pending access requests at the time of their creation.
								// These annotations serve as a mechanism to propagate extra information
								// to plugins.  Since these annotations support variable interpolation
								// syntax, they also offer a mechanism for forwarding claims from an
								// external identity provider, to a plugin via `{{external.trait_name}}`
								// style substitutions.
								"annotations": {
									Name:          "Annotations",
									IsTime:        false,
									IsDuration:    false,
									FromTerraform: FromTerraformTraits,
									ToTerraform:   ToTerraformTraits,
								},
								// Thresholds is a list of thresholds, one of which must be met in order for reviews
								// to trigger a state-transition.  If no thresholds are provided, a default threshold
								// of 1 for approval and denial is used.
								"thresholds": {
									Name:       "Thresholds",
									IsTime:     false,
									IsDuration: false,
									Nested: map[string]*accessors.SchemaMeta{
										// Name is the optional human-readable name of the threshold.
										"name": {
											Name:       "Name",
											IsTime:     false,
											IsDuration: false,
										},
										// Filter is an optional predicate used to determine which reviews
										// count toward this threshold.
										"filter": {
											Name:       "Filter",
											IsTime:     false,
											IsDuration: false,
										},
										// Approve is the number of matching approvals needed for state-transition.
										"approve": {
											Name:       "Approve",
											IsTime:     false,
											IsDuration: false,
										},
										// Deny is the number of denials needed for state-transition.
										"deny": {
											Name:       "Deny",
											IsTime:     false,
											IsDuration: false,
										},
									},
								},
								// SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but
								// that is not a requirement.
								"suggested_reviewers": {
									Name:       "SuggestedReviewers",
									IsTime:     false,
									IsDuration: false,
								},
							},
						},
						// KubeUsers is an optional kubernetes users to impersonate
						"kubernetes_users": {
							Name:       "KubeUsers",
							IsTime:     false,
							IsDuration: false,
						},
						// AppLabels is a map of labels used as part of the RBAC system.
						"app_labels": {
							Name:          "AppLabels",
							IsTime:        false,
							IsDuration:    false,
							FromTerraform: FromTerraformLabels,
							ToTerraform:   ToTerraformLabels,
						},
						// ClusterLabels is a map of node labels (used to dynamically grant access to
						// clusters).
						"cluster_labels": {
							Name:          "ClusterLabels",
							IsTime:        false,
							IsDuration:    false,
							FromTerraform: FromTerraformLabels,
							ToTerraform:   ToTerraformLabels,
						},
						// KubernetesLabels is a map of kubernetes cluster labels used for RBAC.
						"kubernetes_labels": {
							Name:          "KubernetesLabels",
							IsTime:        false,
							IsDuration:    false,
							FromTerraform: FromTerraformLabels,
							ToTerraform:   ToTerraformLabels,
						},
						// DatabaseLabels are used in RBAC system to allow/deny access to databases.
						"db_labels": {
							Name:          "DatabaseLabels",
							IsTime:        false,
							IsDuration:    false,
							FromTerraform: FromTerraformLabels,
							ToTerraform:   ToTerraformLabels,
						},
						// DatabaseNames is a list of database names this role is allowed to connect to.
						"db_names": {
							Name:       "DatabaseNames",
							IsTime:     false,
							IsDuration: false,
						},
						// DatabaseUsers is a list of databaes users this role is allowed to connect as.
						"db_users": {
							Name:       "DatabaseUsers",
							IsTime:     false,
							IsDuration: false,
						},
						// Impersonate specifies what users and roles this role is allowed to impersonate
						// by issuing certificates or other possible means.
						"impersonate": {
							Name:       "Impersonate",
							IsTime:     false,
							IsDuration: false,
							Nested: map[string]*accessors.SchemaMeta{
								// Users is a list of resources this role is allowed to impersonate,
								// could be an empty list or a Wildcard pattern
								"users": {
									Name:       "Users",
									IsTime:     false,
									IsDuration: false,
								},
								// Roles is a list of resources this role is allowed to impersonate
								"roles": {
									Name:       "Roles",
									IsTime:     false,
									IsDuration: false,
								},
								// Where specifies optional advanced matcher
								"where": {
									Name:       "Where",
									IsTime:     false,
									IsDuration: false,
								},
							},
						},
						// ReviewRequests defines conditions for submitting access reviews.
						"review_requests": {
							Name:       "ReviewRequests",
							IsTime:     false,
							IsDuration: false,
							Nested: map[string]*accessors.SchemaMeta{
								// Roles is the name of roles which may be reviewed.
								"roles": {
									Name:       "Roles",
									IsTime:     false,
									IsDuration: false,
								},
								// ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
								"claims_to_roles": {
									Name:       "ClaimsToRoles",
									IsTime:     false,
									IsDuration: false,
									Nested: map[string]*accessors.SchemaMeta{
										// Claim is a claim name.
										"claim": {
											Name:       "Claim",
											IsTime:     false,
											IsDuration: false,
										},
										// Value is a claim value to match.
										"value": {
											Name:       "Value",
											IsTime:     false,
											IsDuration: false,
										},
										// Roles is a list of static teleport roles to match.
										"roles": {
											Name:       "Roles",
											IsTime:     false,
											IsDuration: false,
										},
									},
								},
								// Where is an optional predicate which further limits which requests are
								// reviewable.
								"where": {
									Name:       "Where",
									IsTime:     false,
									IsDuration: false,
								},
							},
						},
						// AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.
						"aws_role_arns": {
							Name:       "AWSRoleARNs",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
				// Deny is the set of conditions evaluated to deny access. Deny takes priority
				// over allow.
				"deny": {
					Name:       "Deny",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// Logins is a list of *nix system logins.
						"logins": {
							Name:       "Logins",
							IsTime:     false,
							IsDuration: false,
						},
						// NodeLabels is a map of node labels (used to dynamically grant access to
						// nodes).
						"node_labels": {
							Name:          "NodeLabels",
							IsTime:        false,
							IsDuration:    false,
							FromTerraform: FromTerraformLabels,
							ToTerraform:   ToTerraformLabels,
						},
						// Rules is a list of rules and their access levels. Rules are a high level
						// construct used for access control.
						"rules": {
							Name:       "Rules",
							IsTime:     false,
							IsDuration: false,
							Nested: map[string]*accessors.SchemaMeta{
								// Resources is a list of resources
								"resources": {
									Name:       "Resources",
									IsTime:     false,
									IsDuration: false,
								},
								// Verbs is a list of verbs
								"verbs": {
									Name:       "Verbs",
									IsTime:     false,
									IsDuration: false,
								},
								// Where specifies optional advanced matcher
								"where": {
									Name:       "Where",
									IsTime:     false,
									IsDuration: false,
								},
								// Actions specifies optional actions taken when this rule matches
								"actions": {
									Name:       "Actions",
									IsTime:     false,
									IsDuration: false,
								},
							},
						},
						// KubeGroups is a list of kubernetes groups
						"kubernetes_groups": {
							Name:       "KubeGroups",
							IsTime:     false,
							IsDuration: false,
						},

						"request": {
							Name:       "Request",
							IsTime:     false,
							IsDuration: false,
							Nested: map[string]*accessors.SchemaMeta{
								// Roles is the name of roles which will match the request rule.
								"roles": {
									Name:       "Roles",
									IsTime:     false,
									IsDuration: false,
								},
								// ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
								"claims_to_roles": {
									Name:       "ClaimsToRoles",
									IsTime:     false,
									IsDuration: false,
									Nested: map[string]*accessors.SchemaMeta{
										// Claim is a claim name.
										"claim": {
											Name:       "Claim",
											IsTime:     false,
											IsDuration: false,
										},
										// Value is a claim value to match.
										"value": {
											Name:       "Value",
											IsTime:     false,
											IsDuration: false,
										},
										// Roles is a list of static teleport roles to match.
										"roles": {
											Name:       "Roles",
											IsTime:     false,
											IsDuration: false,
										},
									},
								},
								// Annotations is a collection of annotations to be programmatically
								// appended to pending access requests at the time of their creation.
								// These annotations serve as a mechanism to propagate extra information
								// to plugins.  Since these annotations support variable interpolation
								// syntax, they also offer a mechanism for forwarding claims from an
								// external identity provider, to a plugin via `{{external.trait_name}}`
								// style substitutions.
								"annotations": {
									Name:          "Annotations",
									IsTime:        false,
									IsDuration:    false,
									FromTerraform: FromTerraformTraits,
									ToTerraform:   ToTerraformTraits,
								},
								// Thresholds is a list of thresholds, one of which must be met in order for reviews
								// to trigger a state-transition.  If no thresholds are provided, a default threshold
								// of 1 for approval and denial is used.
								"thresholds": {
									Name:       "Thresholds",
									IsTime:     false,
									IsDuration: false,
									Nested: map[string]*accessors.SchemaMeta{
										// Name is the optional human-readable name of the threshold.
										"name": {
											Name:       "Name",
											IsTime:     false,
											IsDuration: false,
										},
										// Filter is an optional predicate used to determine which reviews
										// count toward this threshold.
										"filter": {
											Name:       "Filter",
											IsTime:     false,
											IsDuration: false,
										},
										// Approve is the number of matching approvals needed for state-transition.
										"approve": {
											Name:       "Approve",
											IsTime:     false,
											IsDuration: false,
										},
										// Deny is the number of denials needed for state-transition.
										"deny": {
											Name:       "Deny",
											IsTime:     false,
											IsDuration: false,
										},
									},
								},
								// SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but
								// that is not a requirement.
								"suggested_reviewers": {
									Name:       "SuggestedReviewers",
									IsTime:     false,
									IsDuration: false,
								},
							},
						},
						// KubeUsers is an optional kubernetes users to impersonate
						"kubernetes_users": {
							Name:       "KubeUsers",
							IsTime:     false,
							IsDuration: false,
						},
						// AppLabels is a map of labels used as part of the RBAC system.
						"app_labels": {
							Name:          "AppLabels",
							IsTime:        false,
							IsDuration:    false,
							FromTerraform: FromTerraformLabels,
							ToTerraform:   ToTerraformLabels,
						},
						// ClusterLabels is a map of node labels (used to dynamically grant access to
						// clusters).
						"cluster_labels": {
							Name:          "ClusterLabels",
							IsTime:        false,
							IsDuration:    false,
							FromTerraform: FromTerraformLabels,
							ToTerraform:   ToTerraformLabels,
						},
						// KubernetesLabels is a map of kubernetes cluster labels used for RBAC.
						"kubernetes_labels": {
							Name:          "KubernetesLabels",
							IsTime:        false,
							IsDuration:    false,
							FromTerraform: FromTerraformLabels,
							ToTerraform:   ToTerraformLabels,
						},
						// DatabaseLabels are used in RBAC system to allow/deny access to databases.
						"db_labels": {
							Name:          "DatabaseLabels",
							IsTime:        false,
							IsDuration:    false,
							FromTerraform: FromTerraformLabels,
							ToTerraform:   ToTerraformLabels,
						},
						// DatabaseNames is a list of database names this role is allowed to connect to.
						"db_names": {
							Name:       "DatabaseNames",
							IsTime:     false,
							IsDuration: false,
						},
						// DatabaseUsers is a list of databaes users this role is allowed to connect as.
						"db_users": {
							Name:       "DatabaseUsers",
							IsTime:     false,
							IsDuration: false,
						},
						// Impersonate specifies what users and roles this role is allowed to impersonate
						// by issuing certificates or other possible means.
						"impersonate": {
							Name:       "Impersonate",
							IsTime:     false,
							IsDuration: false,
							Nested: map[string]*accessors.SchemaMeta{
								// Users is a list of resources this role is allowed to impersonate,
								// could be an empty list or a Wildcard pattern
								"users": {
									Name:       "Users",
									IsTime:     false,
									IsDuration: false,
								},
								// Roles is a list of resources this role is allowed to impersonate
								"roles": {
									Name:       "Roles",
									IsTime:     false,
									IsDuration: false,
								},
								// Where specifies optional advanced matcher
								"where": {
									Name:       "Where",
									IsTime:     false,
									IsDuration: false,
								},
							},
						},
						// ReviewRequests defines conditions for submitting access reviews.
						"review_requests": {
							Name:       "ReviewRequests",
							IsTime:     false,
							IsDuration: false,
							Nested: map[string]*accessors.SchemaMeta{
								// Roles is the name of roles which may be reviewed.
								"roles": {
									Name:       "Roles",
									IsTime:     false,
									IsDuration: false,
								},
								// ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
								"claims_to_roles": {
									Name:       "ClaimsToRoles",
									IsTime:     false,
									IsDuration: false,
									Nested: map[string]*accessors.SchemaMeta{
										// Claim is a claim name.
										"claim": {
											Name:       "Claim",
											IsTime:     false,
											IsDuration: false,
										},
										// Value is a claim value to match.
										"value": {
											Name:       "Value",
											IsTime:     false,
											IsDuration: false,
										},
										// Roles is a list of static teleport roles to match.
										"roles": {
											Name:       "Roles",
											IsTime:     false,
											IsDuration: false,
										},
									},
								},
								// Where is an optional predicate which further limits which requests are
								// reviewable.
								"where": {
									Name:       "Where",
									IsTime:     false,
									IsDuration: false,
								},
							},
						},
						// AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.
						"aws_role_arns": {
							Name:       "AWSRoleARNs",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
			},
		},
	}
}

// SchemaUserV2 returns schema for UserV2
//
// UserV2 is version 2 resource spec of the user
func GenSchemaUserV2() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		// Kind is a resource kind
		"kind": {
			Type:        schema.TypeString,
			Description: "Kind is a resource kind",
			Optional:    true,
			Computed:    true,
		},
		// SubKind is an optional resource sub kind, used in some resources
		"sub_kind": {
			Type:        schema.TypeString,
			Description: "SubKind is an optional resource sub kind, used in some resources",
			Optional:    true,
		},
		// Version is version
		"version": {
			Type:        schema.TypeString,
			Description: "Version is version",
			Optional:    true,
			Computed:    true,
		},
		// Metadata is resource metadata
		"metadata": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "Metadata is resource metadata",

			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Name is an object name
					"name": {
						Type:        schema.TypeString,
						Description: "Name is an object name",
						Required:    true,
						ForceNew:    true,
					},
					// Namespace is object namespace. The field should be called "namespace"
					// when it returns in Teleport 2.4.
					"namespace": {
						Type:        schema.TypeString,
						Description: "Namespace is object namespace. The field should be called \"namespace\"  when it returns in Teleport 2.4.",
						Optional:    true,
						Computed:    true,
					},
					// Description is object description
					"description": {
						Type:        schema.TypeString,
						Description: "Description is object description",
						Optional:    true,
					},
					// Labels is a set of labels
					"labels": {

						Optional:    true,
						Type:        schema.TypeMap,
						Description: "Labels is a set of labels",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},
					// Expires is a global expiry time header can be set on any resource in the
					// system.
					"expires": {
						Type:         schema.TypeString,
						Description:  "Expires is a global expiry time header can be set on any resource in the  system.",
						ValidateFunc: validation.IsRFC3339Time,
						StateFunc:    TruncateMs,
						Optional:     true,
					},
				},
			},
		},
		// Spec is a user specification
		"spec": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "UserSpecV2 is a specification for V2 user",

			Required: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// OIDCIdentities lists associated OpenID Connect identities
					// that let user log in using externally verified identity
					"oidc_identities": {

						Optional:    true,
						Type:        schema.TypeList,
						Description: "OIDCIdentities lists associated OpenID Connect identities  that let user log in using externally verified identity",
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
								"connector_id": {
									Type:        schema.TypeString,
									Description: "ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'",
									Optional:    true,
								},
								// Username is username supplied by external identity provider
								"username": {
									Type:        schema.TypeString,
									Description: "Username is username supplied by external identity provider",
									Optional:    true,
								},
							},
						},
					},
					// SAMLIdentities lists associated SAML identities
					// that let user log in using externally verified identity
					"saml_identities": {

						Optional:    true,
						Type:        schema.TypeList,
						Description: "SAMLIdentities lists associated SAML identities  that let user log in using externally verified identity",
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
								"connector_id": {
									Type:        schema.TypeString,
									Description: "ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'",
									Optional:    true,
								},
								// Username is username supplied by external identity provider
								"username": {
									Type:        schema.TypeString,
									Description: "Username is username supplied by external identity provider",
									Optional:    true,
								},
							},
						},
					},
					// GithubIdentities list associated Github OAuth2 identities
					// that let user log in using externally verified identity
					"github_identities": {

						Optional:    true,
						Type:        schema.TypeList,
						Description: "GithubIdentities list associated Github OAuth2 identities  that let user log in using externally verified identity",
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
								"connector_id": {
									Type:        schema.TypeString,
									Description: "ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'",
									Optional:    true,
								},
								// Username is username supplied by external identity provider
								"username": {
									Type:        schema.TypeString,
									Description: "Username is username supplied by external identity provider",
									Optional:    true,
								},
							},
						},
					},
					// Roles is a list of roles assigned to user
					"roles": {

						Optional:    true,
						Type:        schema.TypeList,
						Description: "Roles is a list of roles assigned to user",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},
					// Traits are key/value pairs received from an identity provider (through
					// OIDC claims or SAML assertions) or from a system administrator for local
					// accounts. Traits are used to populate role variables.
					"traits": SchemaTraits(),
				},
			},
		},
	}
}

// GenSchemaMetaUserV2 returns schema for UserV2
//
// UserV2 is version 2 resource spec of the user
func GenSchemaMetaUserV2() map[string]*accessors.SchemaMeta {
	return map[string]*accessors.SchemaMeta{
		// Kind is a resource kind
		"kind": {
			Name:       "Kind",
			IsTime:     false,
			IsDuration: false,
		},
		// SubKind is an optional resource sub kind, used in some resources
		"sub_kind": {
			Name:       "SubKind",
			IsTime:     false,
			IsDuration: false,
		},
		// Version is version
		"version": {
			Name:       "Version",
			IsTime:     false,
			IsDuration: false,
		},
		// Metadata is resource metadata
		"metadata": {
			Name:       "Metadata",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Name is an object name
				"name": {
					Name:       "Name",
					IsTime:     false,
					IsDuration: false,
				},
				// Namespace is object namespace. The field should be called "namespace"
				// when it returns in Teleport 2.4.
				"namespace": {
					Name:       "Namespace",
					IsTime:     false,
					IsDuration: false,
				},
				// Description is object description
				"description": {
					Name:       "Description",
					IsTime:     false,
					IsDuration: false,
				},
				// Labels is a set of labels
				"labels": {
					Name:       "Labels",
					IsTime:     false,
					IsDuration: false,
				},
				// Expires is a global expiry time header can be set on any resource in the
				// system.
				"expires": {
					Name:       "Expires",
					IsTime:     true,
					IsDuration: false,
				},
			},
		},
		// Spec is a user specification
		"spec": {
			Name:       "Spec",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// OIDCIdentities lists associated OpenID Connect identities
				// that let user log in using externally verified identity
				"oidc_identities": {
					Name:       "OIDCIdentities",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
						"connector_id": {
							Name:       "ConnectorID",
							IsTime:     false,
							IsDuration: false,
						},
						// Username is username supplied by external identity provider
						"username": {
							Name:       "Username",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
				// SAMLIdentities lists associated SAML identities
				// that let user log in using externally verified identity
				"saml_identities": {
					Name:       "SAMLIdentities",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
						"connector_id": {
							Name:       "ConnectorID",
							IsTime:     false,
							IsDuration: false,
						},
						// Username is username supplied by external identity provider
						"username": {
							Name:       "Username",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
				// GithubIdentities list associated Github OAuth2 identities
				// that let user log in using externally verified identity
				"github_identities": {
					Name:       "GithubIdentities",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
						"connector_id": {
							Name:       "ConnectorID",
							IsTime:     false,
							IsDuration: false,
						},
						// Username is username supplied by external identity provider
						"username": {
							Name:       "Username",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
				// Roles is a list of roles assigned to user
				"roles": {
					Name:       "Roles",
					IsTime:     false,
					IsDuration: false,
				},
				// Traits are key/value pairs received from an identity provider (through
				// OIDC claims or SAML assertions) or from a system administrator for local
				// accounts. Traits are used to populate role variables.
				"traits": {
					Name:          "Traits",
					IsTime:        false,
					IsDuration:    false,
					FromTerraform: FromTerraformTraits,
					ToTerraform:   ToTerraformTraits,
				},
			},
		},
	}
}

// SchemaOIDCConnectorV2 returns schema for OIDCConnectorV2
//
// OIDCConnectorV2 represents an OIDC connector.
func GenSchemaOIDCConnectorV2() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		// Kind is a resource kind.
		"kind": {
			Type:        schema.TypeString,
			Description: "Kind is a resource kind.",
			Optional:    true,
			Computed:    true,
		},
		// SubKind is an optional resource sub kind, used in some resources.
		"sub_kind": {
			Type:        schema.TypeString,
			Description: "SubKind is an optional resource sub kind, used in some resources.",
			Optional:    true,
		},
		// Version is a resource version.
		"version": {
			Type:        schema.TypeString,
			Description: "Version is a resource version.",
			Optional:    true,
			Computed:    true,
		},
		// Metadata holds resource metadata.
		"metadata": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "Metadata is resource metadata",

			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Name is an object name
					"name": {
						Type:        schema.TypeString,
						Description: "Name is an object name",
						Required:    true,
						ForceNew:    true,
					},
					// Namespace is object namespace. The field should be called "namespace"
					// when it returns in Teleport 2.4.
					"namespace": {
						Type:        schema.TypeString,
						Description: "Namespace is object namespace. The field should be called \"namespace\"  when it returns in Teleport 2.4.",
						Optional:    true,
						Computed:    true,
					},
					// Description is object description
					"description": {
						Type:        schema.TypeString,
						Description: "Description is object description",
						Optional:    true,
					},
					// Labels is a set of labels
					"labels": {

						Optional:    true,
						Type:        schema.TypeMap,
						Description: "Labels is a set of labels",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},
					// Expires is a global expiry time header can be set on any resource in the
					// system.
					"expires": {
						Type:         schema.TypeString,
						Description:  "Expires is a global expiry time header can be set on any resource in the  system.",
						ValidateFunc: validation.IsRFC3339Time,
						StateFunc:    TruncateMs,
						Optional:     true,
					},
				},
			},
		},
		// Spec is an OIDC connector specification.
		"spec": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "OIDCConnectorSpecV2 is an OIDC connector specification.   It specifies configuration for Open ID Connect compatible external  identity provider: https://openid.net/specs/openid-connect-core-1_0.html",

			Required: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// IssuerURL is the endpoint of the provider, e.g. https://accounts.google.com.
					"issuer_url": {
						Type:        schema.TypeString,
						Description: "IssuerURL is the endpoint of the provider, e.g. https://accounts.google.com.",
						Optional:    true,
					},
					// ClientID is the id of the authentication client (Teleport Auth server).
					"client_id": {
						Type:        schema.TypeString,
						Description: "ClientID is the id of the authentication client (Teleport Auth server).",
						Optional:    true,
					},
					// ClientSecret is used to authenticate the client.
					"client_secret": {
						Type:        schema.TypeString,
						Description: "ClientSecret is used to authenticate the client.",
						Optional:    true,
					},
					// RedirectURL is a URL that will redirect the client's browser
					// back to the identity provider after successful authentication.
					// This should match the URL on the Provider's side.
					"redirect_url": {
						Type:        schema.TypeString,
						Description: "RedirectURL is a URL that will redirect the client's browser  back to the identity provider after successful authentication.  This should match the URL on the Provider's side.",
						Optional:    true,
					},
					// ACR is an Authentication Context Class Reference value. The meaning of the ACR
					// value is context-specific and varies for identity providers.
					"acr_values": {
						Type:        schema.TypeString,
						Description: "ACR is an Authentication Context Class Reference value. The meaning of the ACR  value is context-specific and varies for identity providers.",
						Optional:    true,
					},
					// Provider is the external identity provider.
					"provider": {
						Type:        schema.TypeString,
						Description: "Provider is the external identity provider.",
						Optional:    true,
					},
					// Display is the friendly name for this provider.
					"display": {
						Type:        schema.TypeString,
						Description: "Display is the friendly name for this provider.",
						Optional:    true,
					},
					// Scope specifies additional scopes set by provider.
					"scope": {

						Optional:    true,
						Type:        schema.TypeList,
						Description: "Scope specifies additional scopes set by provider.",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},
					// Prompt is an optional OIDC prompt. An empty string omits prompt.
					// If not specified, it defaults to select_account for backwards compatibility.
					"prompt": {
						Type:        schema.TypeString,
						Description: "Prompt is an optional OIDC prompt. An empty string omits prompt.  If not specified, it defaults to select_account for backwards compatibility.",
						Optional:    true,
					},
					// ClaimsToRoles specifies a dynamic mapping from claims to roles.
					"claims_to_roles": {

						Optional:    true,
						Type:        schema.TypeList,
						Description: "ClaimsToRoles specifies a dynamic mapping from claims to roles.",
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// Claim is a claim name.
								"claim": {
									Type:        schema.TypeString,
									Description: "Claim is a claim name.",
									Optional:    true,
								},
								// Value is a claim value to match.
								"value": {
									Type:        schema.TypeString,
									Description: "Value is a claim value to match.",
									Optional:    true,
								},
								// Roles is a list of static teleport roles to match.
								"roles": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "Roles is a list of static teleport roles to match.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
							},
						},
					},
					// GoogleServiceAccountURI is a path to a google service account uri.
					"google_service_account_uri": {
						Type:        schema.TypeString,
						Description: "GoogleServiceAccountURI is a path to a google service account uri.",
						Optional:    true,
					},
					// GoogleServiceAccount is a string containing google service account credentials.
					"google_service_account": {
						Type:        schema.TypeString,
						Description: "GoogleServiceAccount is a string containing google service account credentials.",
						Optional:    true,
					},
					// GoogleAdminEmail is the email of a google admin to impersonate.
					"google_admin_email": {
						Type:        schema.TypeString,
						Description: "GoogleAdminEmail is the email of a google admin to impersonate.",
						Optional:    true,
					},
				},
			},
		},
	}
}

// GenSchemaMetaOIDCConnectorV2 returns schema for OIDCConnectorV2
//
// OIDCConnectorV2 represents an OIDC connector.
func GenSchemaMetaOIDCConnectorV2() map[string]*accessors.SchemaMeta {
	return map[string]*accessors.SchemaMeta{
		// Kind is a resource kind.
		"kind": {
			Name:       "Kind",
			IsTime:     false,
			IsDuration: false,
		},
		// SubKind is an optional resource sub kind, used in some resources.
		"sub_kind": {
			Name:       "SubKind",
			IsTime:     false,
			IsDuration: false,
		},
		// Version is a resource version.
		"version": {
			Name:       "Version",
			IsTime:     false,
			IsDuration: false,
		},
		// Metadata holds resource metadata.
		"metadata": {
			Name:       "Metadata",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Name is an object name
				"name": {
					Name:       "Name",
					IsTime:     false,
					IsDuration: false,
				},
				// Namespace is object namespace. The field should be called "namespace"
				// when it returns in Teleport 2.4.
				"namespace": {
					Name:       "Namespace",
					IsTime:     false,
					IsDuration: false,
				},
				// Description is object description
				"description": {
					Name:       "Description",
					IsTime:     false,
					IsDuration: false,
				},
				// Labels is a set of labels
				"labels": {
					Name:       "Labels",
					IsTime:     false,
					IsDuration: false,
				},
				// Expires is a global expiry time header can be set on any resource in the
				// system.
				"expires": {
					Name:       "Expires",
					IsTime:     true,
					IsDuration: false,
				},
			},
		},
		// Spec is an OIDC connector specification.
		"spec": {
			Name:       "Spec",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// IssuerURL is the endpoint of the provider, e.g. https://accounts.google.com.
				"issuer_url": {
					Name:       "IssuerURL",
					IsTime:     false,
					IsDuration: false,
				},
				// ClientID is the id of the authentication client (Teleport Auth server).
				"client_id": {
					Name:       "ClientID",
					IsTime:     false,
					IsDuration: false,
				},
				// ClientSecret is used to authenticate the client.
				"client_secret": {
					Name:       "ClientSecret",
					IsTime:     false,
					IsDuration: false,
				},
				// RedirectURL is a URL that will redirect the client's browser
				// back to the identity provider after successful authentication.
				// This should match the URL on the Provider's side.
				"redirect_url": {
					Name:       "RedirectURL",
					IsTime:     false,
					IsDuration: false,
				},
				// ACR is an Authentication Context Class Reference value. The meaning of the ACR
				// value is context-specific and varies for identity providers.
				"acr_values": {
					Name:       "ACR",
					IsTime:     false,
					IsDuration: false,
				},
				// Provider is the external identity provider.
				"provider": {
					Name:       "Provider",
					IsTime:     false,
					IsDuration: false,
				},
				// Display is the friendly name for this provider.
				"display": {
					Name:       "Display",
					IsTime:     false,
					IsDuration: false,
				},
				// Scope specifies additional scopes set by provider.
				"scope": {
					Name:       "Scope",
					IsTime:     false,
					IsDuration: false,
				},
				// Prompt is an optional OIDC prompt. An empty string omits prompt.
				// If not specified, it defaults to select_account for backwards compatibility.
				"prompt": {
					Name:       "Prompt",
					IsTime:     false,
					IsDuration: false,
				},
				// ClaimsToRoles specifies a dynamic mapping from claims to roles.
				"claims_to_roles": {
					Name:       "ClaimsToRoles",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// Claim is a claim name.
						"claim": {
							Name:       "Claim",
							IsTime:     false,
							IsDuration: false,
						},
						// Value is a claim value to match.
						"value": {
							Name:       "Value",
							IsTime:     false,
							IsDuration: false,
						},
						// Roles is a list of static teleport roles to match.
						"roles": {
							Name:       "Roles",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
				// GoogleServiceAccountURI is a path to a google service account uri.
				"google_service_account_uri": {
					Name:       "GoogleServiceAccountURI",
					IsTime:     false,
					IsDuration: false,
				},
				// GoogleServiceAccount is a string containing google service account credentials.
				"google_service_account": {
					Name:       "GoogleServiceAccount",
					IsTime:     false,
					IsDuration: false,
				},
				// GoogleAdminEmail is the email of a google admin to impersonate.
				"google_admin_email": {
					Name:       "GoogleAdminEmail",
					IsTime:     false,
					IsDuration: false,
				},
			},
		},
	}
}

// SchemaSAMLConnectorV2 returns schema for SAMLConnectorV2
//
// SAMLConnectorV2 represents a SAML connector.
func GenSchemaSAMLConnectorV2() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		// Kind is a resource kind.
		"kind": {
			Type:        schema.TypeString,
			Description: "Kind is a resource kind.",
			Optional:    true,
			Computed:    true,
		},
		// SubKind is an optional resource sub kind, used in some resources.
		"sub_kind": {
			Type:        schema.TypeString,
			Description: "SubKind is an optional resource sub kind, used in some resources.",
			Optional:    true,
		},
		// Version is a resource version.
		"version": {
			Type:        schema.TypeString,
			Description: "Version is a resource version.",
			Optional:    true,
			Computed:    true,
		},
		// Metadata holds resource metadata.
		"metadata": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "Metadata is resource metadata",

			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Name is an object name
					"name": {
						Type:        schema.TypeString,
						Description: "Name is an object name",
						Required:    true,
						ForceNew:    true,
					},
					// Namespace is object namespace. The field should be called "namespace"
					// when it returns in Teleport 2.4.
					"namespace": {
						Type:        schema.TypeString,
						Description: "Namespace is object namespace. The field should be called \"namespace\"  when it returns in Teleport 2.4.",
						Optional:    true,
						Computed:    true,
					},
					// Description is object description
					"description": {
						Type:        schema.TypeString,
						Description: "Description is object description",
						Optional:    true,
					},
					// Labels is a set of labels
					"labels": {

						Optional:    true,
						Type:        schema.TypeMap,
						Description: "Labels is a set of labels",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},
					// Expires is a global expiry time header can be set on any resource in the
					// system.
					"expires": {
						Type:         schema.TypeString,
						Description:  "Expires is a global expiry time header can be set on any resource in the  system.",
						ValidateFunc: validation.IsRFC3339Time,
						StateFunc:    TruncateMs,
						Optional:     true,
					},
				},
			},
		},
		// Spec is an SAML connector specification.
		"spec": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "SAMLConnectorSpecV2 is a SAML connector specification.",

			Required: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Issuer is the identity provider issuer.
					"issuer": {
						Type:        schema.TypeString,
						Description: "Issuer is the identity provider issuer.",
						Optional:    true,
						Computed:    true,
					},
					// SSO is the URL of the identity provider's SSO service.
					"sso": {
						Type:        schema.TypeString,
						Description: "SSO is the URL of the identity provider's SSO service.",
						Optional:    true,
						Computed:    true,
					},
					// Cert is the identity provider certificate PEM.
					// IDP signs <Response> responses using this certificate.
					"cert": {
						Type:        schema.TypeString,
						Description: "Cert is the identity provider certificate PEM.  IDP signs <Response> responses using this certificate.",
						Optional:    true,
						Sensitive:   true,
					},
					// Display controls how this connector is displayed.
					"display": {
						Type:        schema.TypeString,
						Description: "Display controls how this connector is displayed.",
						Optional:    true,
					},
					// AssertionConsumerService is a URL for assertion consumer service
					// on the service provider (Teleport's side).
					"acs": {
						Type:        schema.TypeString,
						Description: "AssertionConsumerService is a URL for assertion consumer service  on the service provider (Teleport's side).",
						Required:    true,
					},
					// Audience uniquely identifies our service provider.
					"audience": {
						Type:        schema.TypeString,
						Description: "Audience uniquely identifies our service provider.",
						Optional:    true,
						Computed:    true,
					},
					// ServiceProviderIssuer is the issuer of the service provider (Teleport).
					"service_provider_issuer": {
						Type:        schema.TypeString,
						Description: "ServiceProviderIssuer is the issuer of the service provider (Teleport).",
						Optional:    true,
						Computed:    true,
					},
					// EntityDescriptor is XML with descriptor. It can be used to supply configuration
					// parameters in one XML file rather than supplying them in the individual elements.
					"entity_descriptor": {
						Type:        schema.TypeString,
						Description: "EntityDescriptor is XML with descriptor. It can be used to supply configuration  parameters in one XML file rather than supplying them in the individual elements.",
						Required:    true,
						Sensitive:   true,
					},
					// EntityDescriptorURL is a URL that supplies a configuration XML.
					"entity_descriptor_url": {
						Type:        schema.TypeString,
						Description: "EntityDescriptorURL is a URL that supplies a configuration XML.",
						Optional:    true,
					},
					// AttributesToRoles is a list of mappings of attribute statements to roles.
					"attributes_to_roles": {

						Required:    true,
						Type:        schema.TypeList,
						Description: "AttributesToRoles is a list of mappings of attribute statements to roles.",
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// Name is an attribute statement name.
								"name": {
									Type:        schema.TypeString,
									Description: "Name is an attribute statement name.",
									Optional:    true,
								},
								// Value is an attribute statement value to match.
								"value": {
									Type:        schema.TypeString,
									Description: "Value is an attribute statement value to match.",
									Optional:    true,
								},
								// Roles is a list of static teleport roles to map to.
								"roles": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "Roles is a list of static teleport roles to map to.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
							},
						},
					},
					// SigningKeyPair is an x509 key pair used to sign AuthnRequest.
					"signing_key_pair": {
						Type:        schema.TypeList,
						MaxItems:    1,
						Description: "AsymmetricKeyPair is a combination of a public certificate and  private key that can be used for encryption and signing.",

						Optional: true,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// PrivateKey is a PEM encoded x509 private key.
								"private_key": {
									Type:        schema.TypeString,
									Description: "PrivateKey is a PEM encoded x509 private key.",
									Optional:    true,
									Computed:    true,
									Sensitive:   true,
								},
								// Cert is a PEM-encoded x509 certificate.
								"cert": {
									Type:        schema.TypeString,
									Description: "Cert is a PEM-encoded x509 certificate.",
									Optional:    true,
									Computed:    true,
								},
							},
						},
					},
					// Provider is the external identity provider.
					"provider": {
						Type:        schema.TypeString,
						Description: "Provider is the external identity provider.",
						Optional:    true,
					},
					// EncryptionKeyPair is a key pair used for decrypting SAML assertions.
					"assertion_key_pair": {
						Type:        schema.TypeList,
						MaxItems:    1,
						Description: "AsymmetricKeyPair is a combination of a public certificate and  private key that can be used for encryption and signing.",

						Optional: true,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// PrivateKey is a PEM encoded x509 private key.
								"private_key": {
									Type:        schema.TypeString,
									Description: "PrivateKey is a PEM encoded x509 private key.",
									Optional:    true,
									Computed:    true,
									Sensitive:   true,
								},
								// Cert is a PEM-encoded x509 certificate.
								"cert": {
									Type:        schema.TypeString,
									Description: "Cert is a PEM-encoded x509 certificate.",
									Optional:    true,
									Computed:    true,
								},
							},
						},
					},
				},
			},
		},
	}
}

// GenSchemaMetaSAMLConnectorV2 returns schema for SAMLConnectorV2
//
// SAMLConnectorV2 represents a SAML connector.
func GenSchemaMetaSAMLConnectorV2() map[string]*accessors.SchemaMeta {
	return map[string]*accessors.SchemaMeta{
		// Kind is a resource kind.
		"kind": {
			Name:       "Kind",
			IsTime:     false,
			IsDuration: false,
		},
		// SubKind is an optional resource sub kind, used in some resources.
		"sub_kind": {
			Name:       "SubKind",
			IsTime:     false,
			IsDuration: false,
		},
		// Version is a resource version.
		"version": {
			Name:       "Version",
			IsTime:     false,
			IsDuration: false,
		},
		// Metadata holds resource metadata.
		"metadata": {
			Name:       "Metadata",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Name is an object name
				"name": {
					Name:       "Name",
					IsTime:     false,
					IsDuration: false,
				},
				// Namespace is object namespace. The field should be called "namespace"
				// when it returns in Teleport 2.4.
				"namespace": {
					Name:       "Namespace",
					IsTime:     false,
					IsDuration: false,
				},
				// Description is object description
				"description": {
					Name:       "Description",
					IsTime:     false,
					IsDuration: false,
				},
				// Labels is a set of labels
				"labels": {
					Name:       "Labels",
					IsTime:     false,
					IsDuration: false,
				},
				// Expires is a global expiry time header can be set on any resource in the
				// system.
				"expires": {
					Name:       "Expires",
					IsTime:     true,
					IsDuration: false,
				},
			},
		},
		// Spec is an SAML connector specification.
		"spec": {
			Name:       "Spec",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Issuer is the identity provider issuer.
				"issuer": {
					Name:       "Issuer",
					IsTime:     false,
					IsDuration: false,
				},
				// SSO is the URL of the identity provider's SSO service.
				"sso": {
					Name:       "SSO",
					IsTime:     false,
					IsDuration: false,
				},
				// Cert is the identity provider certificate PEM.
				// IDP signs <Response> responses using this certificate.
				"cert": {
					Name:       "Cert",
					IsTime:     false,
					IsDuration: false,
				},
				// Display controls how this connector is displayed.
				"display": {
					Name:       "Display",
					IsTime:     false,
					IsDuration: false,
				},
				// AssertionConsumerService is a URL for assertion consumer service
				// on the service provider (Teleport's side).
				"acs": {
					Name:       "AssertionConsumerService",
					IsTime:     false,
					IsDuration: false,
				},
				// Audience uniquely identifies our service provider.
				"audience": {
					Name:       "Audience",
					IsTime:     false,
					IsDuration: false,
				},
				// ServiceProviderIssuer is the issuer of the service provider (Teleport).
				"service_provider_issuer": {
					Name:       "ServiceProviderIssuer",
					IsTime:     false,
					IsDuration: false,
				},
				// EntityDescriptor is XML with descriptor. It can be used to supply configuration
				// parameters in one XML file rather than supplying them in the individual elements.
				"entity_descriptor": {
					Name:       "EntityDescriptor",
					IsTime:     false,
					IsDuration: false,
				},
				// EntityDescriptorURL is a URL that supplies a configuration XML.
				"entity_descriptor_url": {
					Name:       "EntityDescriptorURL",
					IsTime:     false,
					IsDuration: false,
				},
				// AttributesToRoles is a list of mappings of attribute statements to roles.
				"attributes_to_roles": {
					Name:       "AttributesToRoles",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// Name is an attribute statement name.
						"name": {
							Name:       "Name",
							IsTime:     false,
							IsDuration: false,
						},
						// Value is an attribute statement value to match.
						"value": {
							Name:       "Value",
							IsTime:     false,
							IsDuration: false,
						},
						// Roles is a list of static teleport roles to map to.
						"roles": {
							Name:       "Roles",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
				// SigningKeyPair is an x509 key pair used to sign AuthnRequest.
				"signing_key_pair": {
					Name:       "SigningKeyPair",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// PrivateKey is a PEM encoded x509 private key.
						"private_key": {
							Name:       "PrivateKey",
							IsTime:     false,
							IsDuration: false,
						},
						// Cert is a PEM-encoded x509 certificate.
						"cert": {
							Name:       "Cert",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
				// Provider is the external identity provider.
				"provider": {
					Name:       "Provider",
					IsTime:     false,
					IsDuration: false,
				},
				// EncryptionKeyPair is a key pair used for decrypting SAML assertions.
				"assertion_key_pair": {
					Name:       "EncryptionKeyPair",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// PrivateKey is a PEM encoded x509 private key.
						"private_key": {
							Name:       "PrivateKey",
							IsTime:     false,
							IsDuration: false,
						},
						// Cert is a PEM-encoded x509 certificate.
						"cert": {
							Name:       "Cert",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
			},
		},
	}
}

// SchemaGithubConnectorV3 returns schema for GithubConnectorV3
//
// GithubConnectorV3 represents a Github connector.
func GenSchemaGithubConnectorV3() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		// Kind is a resource kind.
		"kind": {
			Type:        schema.TypeString,
			Description: "Kind is a resource kind.",
			Optional:    true,
			Computed:    true,
		},
		// SubKind is an optional resource sub kind, used in some resources.
		"sub_kind": {
			Type:        schema.TypeString,
			Description: "SubKind is an optional resource sub kind, used in some resources.",
			Optional:    true,
		},
		// Version is a resource version.
		"version": {
			Type:        schema.TypeString,
			Description: "Version is a resource version.",
			Optional:    true,
			Computed:    true,
		},
		// Metadata holds resource metadata.
		"metadata": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "Metadata is resource metadata",

			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Name is an object name
					"name": {
						Type:        schema.TypeString,
						Description: "Name is an object name",
						Required:    true,
						ForceNew:    true,
					},
					// Namespace is object namespace. The field should be called "namespace"
					// when it returns in Teleport 2.4.
					"namespace": {
						Type:        schema.TypeString,
						Description: "Namespace is object namespace. The field should be called \"namespace\"  when it returns in Teleport 2.4.",
						Optional:    true,
						Computed:    true,
					},
					// Description is object description
					"description": {
						Type:        schema.TypeString,
						Description: "Description is object description",
						Optional:    true,
					},
					// Labels is a set of labels
					"labels": {

						Optional:    true,
						Type:        schema.TypeMap,
						Description: "Labels is a set of labels",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},
					// Expires is a global expiry time header can be set on any resource in the
					// system.
					"expires": {
						Type:         schema.TypeString,
						Description:  "Expires is a global expiry time header can be set on any resource in the  system.",
						ValidateFunc: validation.IsRFC3339Time,
						StateFunc:    TruncateMs,
						Optional:     true,
					},
				},
			},
		},
		// Spec is an Github connector specification.
		"spec": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "GithubConnectorSpecV3 is a Github connector specification.",

			Required: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// ClientID is the Github OAuth app client ID.
					"client_id": {
						Type:        schema.TypeString,
						Description: "ClientID is the Github OAuth app client ID.",
						Required:    true,
					},
					// ClientSecret is the Github OAuth app client secret.
					"client_secret": {
						Type:        schema.TypeString,
						Description: "ClientSecret is the Github OAuth app client secret.",
						Required:    true,
						Sensitive:   true,
					},
					// RedirectURL is the authorization callback URL.
					"redirect_url": {
						Type:        schema.TypeString,
						Description: "RedirectURL is the authorization callback URL.",
						Optional:    true,
					},
					// TeamsToLogins maps Github team memberships onto allowed logins/roles.
					"teams_to_logins": {

						Required:    true,
						Type:        schema.TypeList,
						Description: "TeamsToLogins maps Github team memberships onto allowed logins/roles.",
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// Organization is a Github organization a user belongs to.
								"organization": {
									Type:        schema.TypeString,
									Description: "Organization is a Github organization a user belongs to.",
									Optional:    true,
								},
								// Team is a team within the organization a user belongs to.
								"team": {
									Type:        schema.TypeString,
									Description: "Team is a team within the organization a user belongs to.",
									Required:    true,
								},
								// Logins is a list of allowed logins for this org/team.
								"logins": {

									Required:    true,
									Type:        schema.TypeList,
									Description: "Logins is a list of allowed logins for this org/team.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
								// KubeGroups is a list of allowed kubernetes groups for this org/team.
								"kubernetes_groups": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "KubeGroups is a list of allowed kubernetes groups for this org/team.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
								// KubeUsers is a list of allowed kubernetes users to impersonate for this org/team.
								"kubernetes_users": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "KubeUsers is a list of allowed kubernetes users to impersonate for this org/team.",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
							},
						},
					},
					// Display is the connector display name.
					"display": {
						Type:        schema.TypeString,
						Description: "Display is the connector display name.",
						Optional:    true,
					},
				},
			},
		},
	}
}

// GenSchemaMetaGithubConnectorV3 returns schema for GithubConnectorV3
//
// GithubConnectorV3 represents a Github connector.
func GenSchemaMetaGithubConnectorV3() map[string]*accessors.SchemaMeta {
	return map[string]*accessors.SchemaMeta{
		// Kind is a resource kind.
		"kind": {
			Name:       "Kind",
			IsTime:     false,
			IsDuration: false,
		},
		// SubKind is an optional resource sub kind, used in some resources.
		"sub_kind": {
			Name:       "SubKind",
			IsTime:     false,
			IsDuration: false,
		},
		// Version is a resource version.
		"version": {
			Name:       "Version",
			IsTime:     false,
			IsDuration: false,
		},
		// Metadata holds resource metadata.
		"metadata": {
			Name:       "Metadata",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Name is an object name
				"name": {
					Name:       "Name",
					IsTime:     false,
					IsDuration: false,
				},
				// Namespace is object namespace. The field should be called "namespace"
				// when it returns in Teleport 2.4.
				"namespace": {
					Name:       "Namespace",
					IsTime:     false,
					IsDuration: false,
				},
				// Description is object description
				"description": {
					Name:       "Description",
					IsTime:     false,
					IsDuration: false,
				},
				// Labels is a set of labels
				"labels": {
					Name:       "Labels",
					IsTime:     false,
					IsDuration: false,
				},
				// Expires is a global expiry time header can be set on any resource in the
				// system.
				"expires": {
					Name:       "Expires",
					IsTime:     true,
					IsDuration: false,
				},
			},
		},
		// Spec is an Github connector specification.
		"spec": {
			Name:       "Spec",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// ClientID is the Github OAuth app client ID.
				"client_id": {
					Name:       "ClientID",
					IsTime:     false,
					IsDuration: false,
				},
				// ClientSecret is the Github OAuth app client secret.
				"client_secret": {
					Name:       "ClientSecret",
					IsTime:     false,
					IsDuration: false,
				},
				// RedirectURL is the authorization callback URL.
				"redirect_url": {
					Name:       "RedirectURL",
					IsTime:     false,
					IsDuration: false,
				},
				// TeamsToLogins maps Github team memberships onto allowed logins/roles.
				"teams_to_logins": {
					Name:       "TeamsToLogins",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// Organization is a Github organization a user belongs to.
						"organization": {
							Name:       "Organization",
							IsTime:     false,
							IsDuration: false,
						},
						// Team is a team within the organization a user belongs to.
						"team": {
							Name:       "Team",
							IsTime:     false,
							IsDuration: false,
						},
						// Logins is a list of allowed logins for this org/team.
						"logins": {
							Name:       "Logins",
							IsTime:     false,
							IsDuration: false,
						},
						// KubeGroups is a list of allowed kubernetes groups for this org/team.
						"kubernetes_groups": {
							Name:       "KubeGroups",
							IsTime:     false,
							IsDuration: false,
						},
						// KubeUsers is a list of allowed kubernetes users to impersonate for this org/team.
						"kubernetes_users": {
							Name:       "KubeUsers",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
				// Display is the connector display name.
				"display": {
					Name:       "Display",
					IsTime:     false,
					IsDuration: false,
				},
			},
		},
	}
}

// SchemaTrustedClusterV2 returns schema for TrustedClusterV2
//
// TrustedClusterV2 represents a Trusted Cluster.
func GenSchemaTrustedClusterV2() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		// Kind is a resource kind.
		"kind": {
			Type:        schema.TypeString,
			Description: "Kind is a resource kind.",
			Optional:    true,
			Computed:    true,
		},
		// SubKind is an optional resource sub kind, used in some resources.
		"sub_kind": {
			Type:        schema.TypeString,
			Description: "SubKind is an optional resource sub kind, used in some resources.",
			Optional:    true,
		},
		// Version is a resource version.
		"version": {
			Type:        schema.TypeString,
			Description: "Version is a resource version.",
			Optional:    true,
			Computed:    true,
		},
		// Metadata holds resource metadata.
		"metadata": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "Metadata is resource metadata",

			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Name is an object name
					"name": {
						Type:        schema.TypeString,
						Description: "Name is an object name",
						Required:    true,
						ForceNew:    true,
					},
					// Namespace is object namespace. The field should be called "namespace"
					// when it returns in Teleport 2.4.
					"namespace": {
						Type:        schema.TypeString,
						Description: "Namespace is object namespace. The field should be called \"namespace\"  when it returns in Teleport 2.4.",
						Optional:    true,
						Computed:    true,
					},
					// Description is object description
					"description": {
						Type:        schema.TypeString,
						Description: "Description is object description",
						Optional:    true,
					},
					// Labels is a set of labels
					"labels": {

						Optional:    true,
						Type:        schema.TypeMap,
						Description: "Labels is a set of labels",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},
					// Expires is a global expiry time header can be set on any resource in the
					// system.
					"expires": {
						Type:         schema.TypeString,
						Description:  "Expires is a global expiry time header can be set on any resource in the  system.",
						ValidateFunc: validation.IsRFC3339Time,
						StateFunc:    TruncateMs,
						Optional:     true,
					},
				},
			},
		},
		// Spec is a Trusted Cluster specification.
		"spec": {
			Type:        schema.TypeList,
			MaxItems:    1,
			Description: "TrustedClusterSpecV2 is a Trusted Cluster specification.",

			Required: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Enabled is a bool that indicates if the TrustedCluster is enabled or disabled.
					// Setting Enabled to false has a side effect of deleting the user and host certificate
					// authority (CA).
					"enabled": {
						Type:        schema.TypeBool,
						Description: "Enabled is a bool that indicates if the TrustedCluster is enabled or disabled.  Setting Enabled to false has a side effect of deleting the user and host certificate  authority (CA).",
						Optional:    true,
					},
					// Roles is a list of roles that users will be assuming when connecting to this cluster.
					"roles": {

						Optional:    true,
						Type:        schema.TypeList,
						Description: "Roles is a list of roles that users will be assuming when connecting to this cluster.",
						Elem: &schema.Schema{
							Type: schema.TypeString,
						},
					},
					// Token is the authorization token provided by another cluster needed by this cluster to join.
					"token": {
						Type:        schema.TypeString,
						Description: "Token is the authorization token provided by another cluster needed by this cluster to join.",
						Optional:    true,
					},
					// ProxyAddress is the address of the web proxy server of the cluster to join. If not set,
					// it is derived from <metadata.name>:<default web proxy server port>.
					"web_proxy_addr": {
						Type:        schema.TypeString,
						Description: "ProxyAddress is the address of the web proxy server of the cluster to join. If not set,  it is derived from <metadata.name>:<default web proxy server port>.",
						Optional:    true,
					},
					// ReverseTunnelAddress is the address of the SSH proxy server of the cluster to join. If
					// not set, it is derived from <metadata.name>:<default reverse tunnel port>.
					"tunnel_addr": {
						Type:        schema.TypeString,
						Description: "ReverseTunnelAddress is the address of the SSH proxy server of the cluster to join. If  not set, it is derived from <metadata.name>:<default reverse tunnel port>.",
						Optional:    true,
					},
					// RoleMap specifies role mappings to remote roles.
					"role_map": {

						Optional:    true,
						Type:        schema.TypeList,
						Description: "RoleMap specifies role mappings to remote roles.",
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// Remote specifies remote role name to map from
								"remote": {
									Type:        schema.TypeString,
									Description: "Remote specifies remote role name to map from",
									Optional:    true,
								},
								// Local specifies local roles to map to
								"local": {

									Optional:    true,
									Type:        schema.TypeList,
									Description: "Local specifies local roles to map to",
									Elem: &schema.Schema{
										Type: schema.TypeString,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// GenSchemaMetaTrustedClusterV2 returns schema for TrustedClusterV2
//
// TrustedClusterV2 represents a Trusted Cluster.
func GenSchemaMetaTrustedClusterV2() map[string]*accessors.SchemaMeta {
	return map[string]*accessors.SchemaMeta{
		// Kind is a resource kind.
		"kind": {
			Name:       "Kind",
			IsTime:     false,
			IsDuration: false,
		},
		// SubKind is an optional resource sub kind, used in some resources.
		"sub_kind": {
			Name:       "SubKind",
			IsTime:     false,
			IsDuration: false,
		},
		// Version is a resource version.
		"version": {
			Name:       "Version",
			IsTime:     false,
			IsDuration: false,
		},
		// Metadata holds resource metadata.
		"metadata": {
			Name:       "Metadata",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Name is an object name
				"name": {
					Name:       "Name",
					IsTime:     false,
					IsDuration: false,
				},
				// Namespace is object namespace. The field should be called "namespace"
				// when it returns in Teleport 2.4.
				"namespace": {
					Name:       "Namespace",
					IsTime:     false,
					IsDuration: false,
				},
				// Description is object description
				"description": {
					Name:       "Description",
					IsTime:     false,
					IsDuration: false,
				},
				// Labels is a set of labels
				"labels": {
					Name:       "Labels",
					IsTime:     false,
					IsDuration: false,
				},
				// Expires is a global expiry time header can be set on any resource in the
				// system.
				"expires": {
					Name:       "Expires",
					IsTime:     true,
					IsDuration: false,
				},
			},
		},
		// Spec is a Trusted Cluster specification.
		"spec": {
			Name:       "Spec",
			IsTime:     false,
			IsDuration: false,
			Nested: map[string]*accessors.SchemaMeta{
				// Enabled is a bool that indicates if the TrustedCluster is enabled or disabled.
				// Setting Enabled to false has a side effect of deleting the user and host certificate
				// authority (CA).
				"enabled": {
					Name:       "Enabled",
					IsTime:     false,
					IsDuration: false,
				},
				// Roles is a list of roles that users will be assuming when connecting to this cluster.
				"roles": {
					Name:       "Roles",
					IsTime:     false,
					IsDuration: false,
				},
				// Token is the authorization token provided by another cluster needed by this cluster to join.
				"token": {
					Name:       "Token",
					IsTime:     false,
					IsDuration: false,
				},
				// ProxyAddress is the address of the web proxy server of the cluster to join. If not set,
				// it is derived from <metadata.name>:<default web proxy server port>.
				"web_proxy_addr": {
					Name:       "ProxyAddress",
					IsTime:     false,
					IsDuration: false,
				},
				// ReverseTunnelAddress is the address of the SSH proxy server of the cluster to join. If
				// not set, it is derived from <metadata.name>:<default reverse tunnel port>.
				"tunnel_addr": {
					Name:       "ReverseTunnelAddress",
					IsTime:     false,
					IsDuration: false,
				},
				// RoleMap specifies role mappings to remote roles.
				"role_map": {
					Name:       "RoleMap",
					IsTime:     false,
					IsDuration: false,
					Nested: map[string]*accessors.SchemaMeta{
						// Remote specifies remote role name to map from
						"remote": {
							Name:       "Remote",
							IsTime:     false,
							IsDuration: false,
						},
						// Local specifies local roles to map to
						"local": {
							Name:       "Local",
							IsTime:     false,
							IsDuration: false,
						},
					},
				},
			},
		},
	}
}
